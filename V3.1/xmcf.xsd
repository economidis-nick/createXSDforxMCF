<?xml version="1.0"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:vc="http://www.w3.org/2007/XMLSchema-versioning" elementFormDefault="qualified" vc:minVersion="1.1">
	<xs:element name="xmcf">
		<xs:complexType>
			<xs:all>
				<xs:element ref="units" minOccurs="0" maxOccurs="1"/>
				<xs:element name="date" type="xs:date" minOccurs="0" maxOccurs="1"/>
				<xs:element name="version" type="xs:string" minOccurs="1" maxOccurs="1"/>
				<xs:element ref="appdata" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="femdata" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="connection_group" minOccurs="0" maxOccurs="unbounded"/>
			</xs:all>
			<xs:assert test="if( ( not(exists(units)) and (exists(connection_group/connection_list/connection_0d/robscan[@orientation_angle lt -180.0]) or exists(connection_group/connection_list/connection_0d/robscan[@orientation_angle gt 180.0]) ) ) or 
						( (units/@angle='deg') and (exists(connection_group/connection_list/connection_0d/robscan[@orientation_angle lt -180.0]) or exists(connection_group/connection_list/connection_0d/robscan[@orientation_angle gt 180.0])) ) or
						( (units/@angle='rad') and (exists(connection_group/connection_list/connection_0d/robscan[@orientation_angle lt -3.14159265358979323846]) or exists(connection_group/connection_list/connection_0d/robscan[@orientation_angle gt 3.14159265358979323846])) ) ) then false() else true()"/>

			<xs:assert test="if( ( not(exists(units)) and (exists(connection_group/connection_list/connection_1d/seamweld/*/sheet_parameter[@sheet_angle lt 0]) or 
											exists(connection_group/connection_list/connection_1d/seamweld/*/sheet_parameter[@sheet_angle ge 360]) ) ) or 
											
						( (units/@angle='deg') and (exists(connection_group/connection_list/connection_1d/seamweld/*/sheet_parameter[@sheet_angle lt 0]) or 
											exists(connection_group/connection_list/connection_1d/seamweld/*/sheet_parameter[@sheet_angle ge 360]) ) ) or 
											
						( (units/@angle='rad') and (exists(connection_group/connection_list/connection_1d/seamweld/*/sheet_parameter[@sheet_angle lt 0]) or 
											exists(connection_group/connection_list/connection_1d/seamweld/*/sheet_parameter[@sheet_angle ge 2*3.14159265358979323846]) ) ) )
						
						then false() else true()"/>
		</xs:complexType>
    
		<!-- connection_group/id must be unique within xmcf -->
		<xs:unique name="iduq">
			<xs:selector xpath="connection_group"/>
			<xs:field xpath="@id"/>
		</xs:unique>
	</xs:element>
	<xs:element name="units">
		<xs:complexType>
			<xs:attribute name="length" default="mm">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="mm"/>
						<xs:enumeration value="m"/>
						<xs:enumeration value="in"/>
						<xs:enumeration value="ft"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="angle" default="deg">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="deg"/>
						<xs:enumeration value="rad"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="mass" default="kg">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="g"/>
						<xs:enumeration value="kg"/>
						<xs:enumeration value="t"/>
						<xs:enumeration value="lb"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="force" default="N">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="kN"/>
						<xs:enumeration value="N"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="time" default="s">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="s"/>
						<xs:enumeration value="min"/>
						<xs:enumeration value="h"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="torque" default="Nm">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="Nm"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="appdata">
		<xs:complexType>
			<!-- 
				NOTE: We chose not to restrict the choice of elements under appdata, because the spec says:
				"The following list does not imply that other application names are forbidden. 
				Its noly purpose is to reserve the registered names against inappropriate use".
			-->
			<!--<xs:choice minOccurs="1" maxOccurs="unbounded">
				<xs:element name="ANSA"/>
				<xs:element name="FEMFAT"/>
				<xs:element name="HyperMesh"/>
				<xs:element name="LMSVirtualLab"/>
				<xs:element name="MEDINA"/>
				<xs:element name="NCODE"/>
				<xs:element name="SyncroFIT"/>
				<xs:any/>
			</xs:choice>-->
			<xs:sequence>
				<xs:any minOccurs="0" processContents="skip"/>
			</xs:sequence>
		</xs:complexType>
	</xs:element>
	<xs:element name="femdata">
		<xs:complexType>
			<!-- 
				NOTE: According to document, the following are the acceptable contents of femdata.
					  In case that more applications would be added, we should use commented code instead.
			-->
			<!--<xs:sequence>
				<xs:any minOccurs="0" processContents="skip"/>
			</xs:sequence>-->
			<xs:all>
				<xs:element name="PAMCRASH" minOccurs="0" maxOccurs="1">
					<xs:complexType>
						<xs:sequence>
							<xs:element ref="CAE_DATA" minOccurs="1" maxOccurs="unbounded"/>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
				<xs:element name="LSDYNA" minOccurs="0" maxOccurs="1">
					<xs:complexType>
						<xs:sequence>
							<xs:element ref="CAE_DATA" minOccurs="1" maxOccurs="unbounded"/>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
				<xs:element name="PERMAS" minOccurs="0" maxOccurs="1">
					<xs:complexType>
						<xs:sequence>
							<xs:element ref="CAE_DATA" minOccurs="1" maxOccurs="unbounded"/>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
				<xs:element name="ABAQUS" minOccurs="0" maxOccurs="1">
					<xs:complexType>
						<xs:sequence>
							<xs:element ref="CAE_DATA" minOccurs="1" maxOccurs="unbounded"/>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
				<xs:element name="RADIOSS" minOccurs="0" maxOccurs="1">
					<xs:complexType>
						<xs:sequence>
							<xs:element ref="CAE_DATA" minOccurs="1" maxOccurs="unbounded"/>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
				<xs:element name="OPTISTRUCT" minOccurs="0" maxOccurs="1">
					<xs:complexType>
						<xs:sequence>
							<xs:element ref="CAE_DATA" minOccurs="1" maxOccurs="unbounded"/>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
				<xs:element name="NASTRAN" minOccurs="0" maxOccurs="1">
					<xs:complexType>
						<xs:sequence>
							<xs:element ref="CAE_DATA" minOccurs="1" maxOccurs="unbounded"/>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
				<xs:element name="FEMFAT" minOccurs="0" maxOccurs="1">
					<xs:complexType>
						<xs:sequence>
							<xs:element ref="CAE_DATA" minOccurs="1" maxOccurs="unbounded"/>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
			</xs:all>
		</xs:complexType>
	</xs:element>
	<xs:element name="CAE_DATA">
		<xs:complexType>
			<xs:all>
				<xs:element name="REPRESENTATION" type="xs:string" minOccurs="0" maxOccurs="1"/>
				<xs:element name="COMMENT" type="xs:string" minOccurs="0" maxOccurs="1"/>
				<xs:element ref="CAE_PART_MEMBER" minOccurs="1" maxOccurs="unbounded"/>
			</xs:all>
			<xs:attribute name="VERSION" type="xs:integer" use="required"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="CAE_PART_MEMBER">
		<xs:complexType>
			<!-- NOTE: <any> is used in order to validate every schema. Alternatively, the following 
					   schema should be used or replaced with FATXML specification.
   			-->
			<!-- 
			<xs:sequence>
				<xs:element name="ENTITY" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:all>
							<xs:element name="TYPE" type="xs:string" minOccurs="1" maxOccurs="1"/>
							<xs:element name="ID" type="xs:string" minOccurs="1" maxOccurs="1"/>
						</xs:all>
					</xs:complexType>
				</xs:element>
			</xs:sequence>
			-->
			<xs:sequence>
				<xs:any minOccurs="0" processContents="skip"/>
			</xs:sequence>
			<xs:attribute name="ID" type="integerPositive"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="connection_group">
		<xs:complexType>
			<xs:all>
				<xs:element ref="connected_to" minOccurs="1" maxOccurs="1"/>			
				<xs:element ref="connection_list" minOccurs="1" maxOccurs="1"/>
				<xs:element ref="contact_list" minOccurs="0" maxOccurs="1"/>
			</xs:all>
			<xs:attribute name="id" type="xs:int" use="required"/>
			<xs:assert test="if( exists(contact_list/contact/partner/@label) and not(every $x in contact_list/contact/partner/@label satisfies 
							( connected_to/part[@label=$x] or connected_to/assy/part[@label=$x] ) ) ) then false() else true()"/>
			<xs:assert test="if( exists(contact_list/contact/partner/@pid)   and not(every $x in contact_list/contact/partner/@pid satisfies 
							( connected_to/part[@pid=$x] or connected_to/assy/part[@pid=$x] ) ) ) then false() else true()"/>
			
			<!-- there can be up to 1 contact with the thread -->
			<xs:assert test="count(connection_list/connection_0d/connection_0d_type/threaded_connection/contact_list/contact[@thread='true']) le 1"/>
      
			<!--contact without thread: "Maximum no. of items = cardinality of <connected_to> -1-->
			<xs:assert test="if ( exists(connection_list/connection_0d/connection_0d_type/threaded_connection/contact_list/contact) and
			count(connection_list/connection_0d/connection_0d_type/threaded_connection/contact_list/contact[@thread='true']) eq 0 and
			count(connection_list/connection_0d/threaded_connection/contact_list/contact) ge ( count(connected_to/part) + count(connected_to/assy) ) ) then false() else true()"/>

			<!--contact with (1) thread: "Maximum no. of items = cardinality of <connected_to> -->
			<xs:assert test="if ( exists(connection_list/connection_0d/connection_0d_type/threaded_connection/contact_list/contact) and
			count(connection_list/connection_0d/connection_0d_type/threaded_connection/contact_list/contact[@thread='true']) eq 1 and
			count(connection_list/connection_0d/threaded_connection/contact_list/contact) gt ( count(connected_to/part) + count(connected_to/assy) ) ) then false() else true()"/>
			
			<!--contact/index: "must be one of the indices defined in <connected_to>, but not the last one of them".-->
			<xs:assert test="if ( exists(connection_list/connection_0d/connection_0d_type/threaded_connection/contact_list/contact) and 
			connection_list/connection_0d/threaded_connection/contact_list/contact/@index eq max( connected_to/*/@index) ) then false() else true()"/>

			<!--sheet_parameter/index: "it must refer to <part> index attribute-->
			<xs:assert test="every $x in connection_list/connection_1d/seamweld/*/sheet_parameter satisfies connected_to/part[@index=$x/@index]"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="contact_list">
		<xs:complexType>
			<xs:all>
				<xs:element name="contact" minOccurs="1" maxOccurs="unbounded">
					<xs:complexType>
						<xs:all>
							<xs:element ref="partner" minOccurs="2" maxOccurs="2"/>
							<xs:element ref="coefficients" minOccurs="1" maxOccurs="1"/>	
						</xs:all>
					</xs:complexType>
				</xs:element>
			</xs:all>
			<!-- 
				NOTE: "any set of physical contact partners must not appear more than once within a <contact_list>".
					      The first <xs:assert>, ensures that every pair of partners is distinct when it appears with the same
					  sequence. 
			          The second and commented <xs:assert>, ensures that every partners'pair is distinct irrespective of the sequence of partners. 
					  An extra check should be added for the case of the contact between one partner.
					  An extra check should be added for the case of pid is used instead of label.
			-->
			<xs:assert test="count(contact) eq count( distinct-values( contact/concat(partner[1]/@label, partner[2]/@label) ) )"/>
			<!--<xs:assert test="(count( distinct-values( contact/concat(partner[1]/@label, partner[2]/@label) ) ) + 
							  count( distinct-values( contact/concat(partner[2]/@label, partner[1]/@label) ) ) -
							  2 * count( distinct-values( contact/concat(partner[1]/@label, partner[1]/@label) ) )) eq 
							 (count( distinct-values( (contact/concat(partner[1]/@label, partner[2]/@label), contact/concat(partner[2]/@label, partner[1]/@label)) ) ) -
							  count( distinct-values( contact/concat(partner[1]/@label, partner[1]/@label) ) ) )"/>-->
		</xs:complexType>
	</xs:element>
	<xs:element name="connected_to">
		<xs:complexType>
			<xs:choice minOccurs="0" maxOccurs="unbounded">
				<xs:element name="part">
					<xs:complexType>
						<xs:attribute name="pid" type="integerPositive"/>
						<xs:attribute name="index" type="integerPositive" use="required"/>
						<xs:attribute name="label" type="xs:string"/>
						
						<xs:assert test="exists(@label) or exists(@pid)"/>
						
					</xs:complexType>
				</xs:element>
				<xs:element name="assy">
					<xs:complexType>
						<xs:sequence>
							<xs:element name="part" minOccurs="2" maxOccurs="unbounded">
								<xs:complexType>
									<xs:attribute name="pid" type="integerPositive"/>
									<xs:attribute name="label" type="xs:string"/>
									
									<xs:assert test="exists(@label) or exists(@pid)"/>

								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attribute name="index" type="xs:integer" use="required"/>
					</xs:complexType>
				</xs:element>
			</xs:choice>
		</xs:complexType>
		<xs:unique name="partΙndexuq">
			<xs:selector xpath="part"/>
			<xs:field xpath="@index"/>
		</xs:unique>
		<xs:unique name="assyΙndexuq">
			<xs:selector xpath="assy"/>
			<xs:field xpath="@index"/>
		</xs:unique>
	</xs:element>
	<xs:element name="partner">
		<xs:complexType>
			<xs:attribute name="label" type="xs:string"/>
			<xs:attribute name="pid" type="integerPositive"/>
			<xs:assert test="exists(@label) or exists(@pid)"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="coefficients">
		<xs:complexType>
			<xs:attribute name="static_friction" type="floatZeroPositive"/>
			<xs:attribute name="kinetic_friction" type="floatZeroPositive"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="connection_list">
		<xs:complexType>
			<xs:choice minOccurs="1" maxOccurs="unbounded">
				<xs:element ref="connection_0d"/>
				<xs:element ref="connection_1d"/>
				<xs:element ref="connection_2d"/>
			</xs:choice>
		</xs:complexType>
	</xs:element>
	<!-- ***************************************************************************************************************************************************************** -->
	<xs:element name="connection_0d">
		<xs:complexType>
			<xs:all>
				<xs:element name="loc" type="xs:string" minOccurs="1" maxOccurs="1"/>
				<xs:element ref="appdata" minOccurs="0" maxOccurs="1"/>
				<xs:element ref="custom_attributes_list" minOccurs="0" maxOccurs="1"/>
				<xs:element ref="connection_0d_type" minOccurs="1" maxOccurs="1"/> <!--"Note: exactly one of the type elements must exist in <connection_od>. There is no default type"-->
			</xs:all>
			<xs:attribute name="label" type="xs:string"/>
			<xs:attribute name="quality_control" type="xs:string"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="connection_0d_type" abstract="true"/>
	<xs:element name="normal_direction">
		<xs:complexType>
			<xs:attribute name="x" type="xs:float" use="required"/>
			<xs:attribute name="y" type="xs:float" use="required"/>
			<xs:attribute name="z" type="xs:float" use="required"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="tangential_direction">
		<xs:complexType>
			<xs:attribute name="x" type="xs:float" use="required"/>
			<xs:attribute name="y" type="xs:float" use="required"/>
			<xs:attribute name="z" type="xs:float" use="required"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="spotweld" substitutionGroup="connection_0d_type sequence_connection_0d_type">
		<xs:complexType>
			<xs:attribute name="diameter" type="floatPositive"/>
			<xs:attribute name="technology">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="resistance"/>
						<xs:enumeration value="laser"/>
						<xs:enumeration value="projection"/>
						<xs:enumeration value="friction"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="robscan" substitutionGroup="connection_0d_type">
		<xs:complexType>
			<xs:all>
				<xs:element ref="normal_direction" minOccurs="0" maxOccurs="1"/>
				<xs:element ref="tangential_direction" minOccurs="0" maxOccurs="1"/>
			</xs:all>
			<xs:attribute name="base" type="integerPositive"/>
			<xs:attribute name="pattern" type="nonEmptyString"/>
			<xs:attribute name="gap" type="floatZeroPositive"/>
			<xs:attribute name="width" type="floatPositive"/>
			<xs:attribute name="pattern_width" type="floatPositive"/>
			<xs:attribute name="pattern_length" type="floatPositive"/>
			<xs:attribute name="mirrored" type="xs:boolean" default="false"/>
			<xs:attribute name="orientation_angle" type="xs:float"/>
			<xs:attribute name="filler_material" type="xs:string"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="rivet" substitutionGroup="connection_0d_type">
		<xs:complexType>
			<xs:all>
				<xs:element ref="normal_direction" minOccurs="0" maxOccurs="1"/>
				<xs:element ref="rivet_type" minOccurs="0" maxOccurs="1"/>
			</xs:all>
			<xs:attribute name="shaft_diameter" type="floatPositive"/>
			<xs:attribute name="length" type="floatPositive"/>
			<xs:attribute name="head_diameter" type="floatPositive"/>
			<xs:attribute name="head_height" type="floatZeroPositive"/>
			<xs:attribute name="head_type" type="xs:string"/>
			<xs:attribute name="sink_size" type="floatZeroPositive"/>
			<xs:attribute name="strength_property_class" type="xs:string"/>
			<xs:attribute name="part_code" type="xs:string"/>
			<xs:assert test=" if ( (exists(@head_height) or exists(@sink_size) ) and (@head_height + @sink_size le 0)) then false() else true()"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="rivet_type" abstract="true"/>
	<xs:element name="blind" substitutionGroup="rivet_type">
		<xs:complexType>
			<xs:attribute name="min_grip" type="floatPositive"/>
			<xs:attribute name="max_grip" type="floatPositive"/>
			<xs:attribute name="clearance" type="floatPositive"/>
			<xs:attribute name="material" type="xs:string"/>
			<xs:assert test="if(exists(@max_grip) and exists(@min_grip) and @max_grip lt @min_grip) then false() else true()"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="self_piercing" substitutionGroup="rivet_type">
		<xs:complexType>
			<xs:attribute name="hardness" type="floatPositive"/>
			<xs:attribute name="head_label" type="xs:string"/>
			<xs:attribute name="shaft_label" type="xs:string"/>
			<xs:attribute name="die_label" type="xs:string"/>
			<xs:attribute name="die_diameter" type="floatPositive"/>
			<xs:attribute name="die_depth" type="floatPositive"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="solid" substitutionGroup="rivet_type">
		<xs:complexType>
			<xs:attribute name="min_grip" type="floatPositive"/>
			<xs:attribute name="max_grip" type="floatPositive"/>
			<xs:attribute name="hole_diameter" type="floatPositive"/>
			<xs:attribute name="hole_depth" type="floatPositive"/>
			<xs:attribute name="shoulder_diameter" type="floatPositive"/>
			<xs:attribute name="shoulder_length" type="floatPositive"/>
			<xs:attribute name="tennon_diameter" type="floatPositive"/>
			<xs:attribute name="tennon_length" type="floatPositive"/>
			
			<!-- max grip >= min_grip -->
			<xs:assert test="if( exists(@max_grip) and exists(@min_grip) and @max_grip lt @min_grip) then false() else true()"/>

			<!--The following are Recommendations:
				"1. hole_diameter is defined with hole_depth and vice versa"
				"2. tennon_diameter exist only if shoulder_diameter is defined and vice versa"
				Therefore they were commented out
			-->
			<!--<xs:assert test="if( ( exists(@hole_diameter) and exists(@hole_depth) ) or ( not(exists(@hole_diameter)) and not(exists(@hole_depth)) ) ) then true() else false()"/>-->
			<!--<xs:assert test="if( ( exists(@tennon_diameter) and exists(@shoulder_diameter) ) or ( not(exists(@tennon_diameter)) and not(exists(@shoulder_diameter)) ) ) then true() else false()"/>-->
    </xs:complexType>
	</xs:element>
	<xs:element name="swop" substitutionGroup="rivet_type">
		<xs:complexType>
			<xs:attribute name="insert_shape" type="xs:string"/>
			<xs:attribute name="insert_height" type="floatPositive"/>
			<xs:attribute name="spotweld_diameter" type="floatPositive"/>
			<xs:attribute name="spotweld_technology">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="resistance"/>
						<xs:enumeration value="laser"/>
						<xs:enumeration value="projection"/>
						<xs:enumeration value="friction"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="threaded_connection" substitutionGroup="connection_0d_type">
		<xs:complexType>
			<xs:all>
				<xs:element ref="normal_direction" minOccurs="0" maxOccurs="1"/>
				<xs:element ref="threaded_connection_type" minOccurs="1" maxOccurs="1"/>
				<xs:element ref="washer" minOccurs="0" maxOccurs="1"/>
				<xs:element name="contact_list" minOccurs="0" maxOccurs="1">
					<xs:complexType>
						<xs:all>
							<xs:element name="contact" minOccurs="1" maxOccurs="unbounded">
								<xs:complexType>
									<xs:attribute name="index" type="integerPositive"/>
									<xs:attribute name="thread" type="xs:boolean" default="false"/>
									<xs:attribute name="static_friction" type="floatPositive"/>
									<xs:attribute name="kinetic_friction" type="floatPositive"/>
                  
									<!--"At least one of these two friction coefficients has to be specified"-->
									<xs:assert test="if( not( exists(@static_friction) ) and not( exists(@kinetic_friction) ) ) then false() else true()"/>
								</xs:complexType>
							</xs:element>
						</xs:all>
					</xs:complexType>
          
					<!--threaded_connection/contact/index: "any specific index may occur not more than once".-->
					<xs:unique name="indexuq">
						<xs:selector xpath="contact"/>
						<xs:field xpath="@index"/>
					</xs:unique>
				</xs:element>
			</xs:all>
			<xs:attribute name="diameter" type="floatZeroPositive"/>
			<xs:attribute name="length" type="floatPositive"/>
			<xs:attribute name="thread_length" type="floatPositive"/>
			<xs:attribute name="head_diameter" type="floatPositive"/>
			<xs:attribute name="head_height" type="floatZeroPositive"/>
			<xs:attribute name="head_type" type="xs:string"/>
			<xs:attribute name="sink_size" type="floatZeroPositive"/>
			<xs:attribute name="pitch" type="floatPositive"/>
			<xs:attribute name="lead" type="floatPositive"/>
			<xs:attribute name="torque" type="floatPositive"/>
			<xs:attribute name="angle" type="floatPositive"/>
			<xs:attribute name="pretension" type="floatPositive"/>
			<xs:attribute name="static_friction" type="floatPositive"/>
			<xs:attribute name="kinetic_friction" type="floatPositive"/>
			<xs:attribute name="strength_property_class" type="xs:string"/>
			<xs:attribute name="part_code" type="xs:string"/>
      
			<!--"length >= thread_length"-->
			<xs:assert test="if( @length lt @thread_length ) then false() else true()"/>
			<!--"If at least one of them is specified, head_height+sink_size>0 is required"-->
			<xs:assert test=" if ( (exists(@head_height) or exists(@sink_size) ) and (@head_height + @sink_size le 0)) then false() else true()"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="threaded_connection_type" abstract="true"/>
	<xs:element name="washer">
		<xs:complexType>
			<xs:attribute name="outer_diameter" type="floatPositive"/>
			<xs:attribute name="inner_diameter" type="floatPositive"/>
			<xs:attribute name="thickness" type="floatPositive"/>
			<xs:attribute name="attached" type="xs:boolean" default="false"/>
			<xs:attribute name="static_friction" type="floatPositive"/>
			<xs:attribute name="kinetic_friction" type="floatPositive"/>
			<xs:attribute name="strength_property_class" type="xs:string"/>
			<xs:attribute name="part_code" type="xs:string"/>
      
			<!--"NO part code, if attached"-->
			<xs:assert test="if( @attached = true() and exists(@part_code) ) then false() else true()"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="nut">
		<xs:complexType>
			<xs:all>
				<xs:element ref="washer" minOccurs="0" maxOccurs="1"/>
			</xs:all>
			<xs:attribute name="diameter" type="floatPositive"/>
			<xs:attribute name="height" type="floatPositive"/>
			<xs:attribute name="torque" type="floatPositive"/>
			<xs:attribute name="angle" type="floatPositive"/>
			<xs:attribute name="static_friction" type="floatPositive"/>
			<xs:attribute name="kinetic_friction" type="floatPositive"/>
			<xs:attribute name="clipped_to" type="integerPositive"/>
			<xs:attribute name="fixed_to" type="integerPositive"/>
			<xs:attribute name="strength_property_class" type="xs:string"/>
			<xs:attribute name="part_code" type="xs:string"/>
      
			<!--"NO part code, if attached"-->
			<xs:assert test="if( ( exists(@clipped_to) or exists(@fixed_to) ) and exists(@part_code) ) then false() else true()"/>
			<!--"Usually nut fixed_to prohibits nut clipped_to and vice versa"-->
			<xs:assert test="if( exists(@fixed_to) and exists(@clipped_to) ) then false() else true()"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="bolt" substitutionGroup="threaded_connection_type">
		<xs:complexType>
			<xs:all>
				<xs:element ref="nut" minOccurs="0" maxOccurs="1"/>
			</xs:all>
			<xs:attribute name="clipped_to" type="integerPositive"/>
			<xs:attribute name="fixed_to" type="integerPositive"/>

			<!--"Usually bolt fixed_to prohibits bolt clipped_to and vice versa"-->
			<xs:assert test="if( exists(@fixed_to) and exists(@clipped_to) ) then false() else true()"/>

			<!--"Usually nut clipped_to or fixed_to prohibits bolt clipped_to or fixed_to and vice versa"-->
			<!--<xs:assert test="if( exists(nut/@fixed_to) and exists(@fixed_to) ) then false() else true()"/>
			<xs:assert test="if( exists(nut/@clipped_to) and exists(@clipped_to) ) then false() else true()"/>-->
			
			<xs:assert test="if( (exists(nut/@fixed_to) or exists(nut/@clipped_to)) and (exists(@fixed_to) or exists(@clipped_to)) ) then false() else true()"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="screw" substitutionGroup="threaded_connection_type">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="flow_drilled" minOccurs="0" maxOccurs="unbounded"/>
			</xs:sequence>
			<xs:attribute name="base" type="integerPositive"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="flow_drilled">
		<xs:complexType>
			<xs:attribute name="pre_machined_hole_diameter" type="floatZeroPositive"/>
			<xs:attribute name="pre_machined_hole_index" type="integerPositive"/>
			<xs:attribute name="pilot_hole_diameter" type="floatZeroPositive"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="gumdrop" substitutionGroup="connection_0d_type sequence_connection_0d_type">
		<xs:complexType>
			<xs:attribute name="diameter" type="floatZeroPositive"/>
			<xs:attribute name="mass" type="floatZeroPositive"/>
			<xs:attribute name="material" type="xs:string"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="clinch" substitutionGroup="connection_0d_type">
		<xs:complexType>
			<xs:all>
				<xs:element ref="normal_direction" minOccurs="0" maxOccurs="1"/>
			</xs:all>
			<xs:attribute name="clinch_type" type="xs:string"/>
			<xs:attribute name="strength_class" type="xs:string"/>
			<xs:attribute name="shear_strength" type="floatPositive"/>
			<xs:attribute name="peel_strength" type="floatPositive"/>
			<xs:attribute name="button_diameter" type="floatPositive"/>
			<xs:attribute name="die_type">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="round"/>
						<xs:enumeration value="rectangular"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="heat_stake" substitutionGroup="connection_0d_type">
		<xs:complexType>
			<xs:all>
				<xs:element ref="normal_direction" minOccurs="0" maxOccurs="1"/>
			</xs:all>
			<xs:attribute name="heat_stake_type" type="xs:string"/>
			<xs:attribute name="strength" type="floatPositive"/>
			<xs:attribute name="diameter" type="floatPositive"/>
			<xs:attribute name="head_diameter" type="floatPositive"/>
			<xs:attribute name="head_height" type="floatZeroPositive"/>
			<xs:attribute name="void_diameter" type="floatZeroPositive"/>
			<xs:attribute name="hole_diameter" type="floatPositive"/>
			<xs:assert test="if( exists(@diameter) and exists(@hole_diameter) and @diameter ge @hole_diameter ) then false() else true()"/>
			<xs:assert test="if( exists(@void_diameter) and exists(@diameter) and @void_diameter ge @diameter ) then false() else true()"/>
			<xs:assert test="if( exists(@hole_diameter) and exists(@head_diameter) and @hole_diameter ge @head_diameter ) then false() else true()"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="clip" substitutionGroup="connection_0d_type">
		<xs:complexType>
			<xs:all>
				<xs:element ref="normal_direction" minOccurs="0" maxOccurs="1"/>
				<xs:element ref="tangential_direction" minOccurs="0" maxOccurs="1"/>
			</xs:all>
			<xs:attribute name="clip_type" type="xs:string"/>
			<xs:attribute name="attachment_type" type="xs:string"/>
			<xs:attribute name="hole_diameter" type="floatZeroPositive"/>
			<xs:attribute name="hole_length" type="floatZeroPositive"/>
			<xs:attribute name="pin_diameter" type="floatZeroPositive"/>
			<xs:attribute name="pin_width" type="floatZeroPositive"/>
			<xs:attribute name="pin_length" type="floatZeroPositive"/>
			<xs:attribute name="strap_length" type="floatZeroPositive"/>
			<xs:attribute name="clipped_to" type="integerPositive"/>
			<xs:attribute name="material" type="xs:string"/>
			<xs:attribute name="part_code" type="xs:string"/>
			<xs:assert test="if( @hole_length gt 0 and @hole_diameter = 0 ) then false() else true()"/>
			<xs:assert test="if( @pin_width gt 0 and @pin_diameter = 0 ) then false() else true()"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="nail" substitutionGroup="connection_0d_type">
		<xs:complexType>
			<xs:all>
				<xs:element ref="normal_direction" minOccurs="0" maxOccurs="1"/>
				<xs:element ref="tangential_direction" minOccurs="0" maxOccurs="1"/>
			</xs:all>
			<xs:attribute name="nail_type" type="xs:string"/>
			<xs:attribute name="shaft_diameter" type="floatPositive"/>
			<xs:attribute name="length" type="floatPositive"/>
			<xs:attribute name="cylinder_length" type="floatPositive"/>
			<xs:attribute name="head_diameter" type="floatPositive"/>
			<xs:attribute name="head_height" type="floatPositive"/>
			<xs:attribute name="shear_strength" type="floatPositive"/>
			<xs:attribute name="peel_strength" type="floatPositive"/>
			<xs:attribute name="material" type="xs:string"/>
			<xs:attribute name="part_code" type="xs:string"/>
		</xs:complexType>
	</xs:element>
	<!-- ************************************************************************************************************************************************************* -->
	<xs:element name="connection_1d">
		<xs:complexType>
			<xs:all>
				<xs:element name="loc_list" minOccurs="1" maxOccurs="unbounded">
					<xs:complexType>
						<xs:sequence>
							<xs:element name="loc" minOccurs="1" maxOccurs="unbounded">
								<xs:complexType>
									<xs:simpleContent>
										<xs:extension base="xs:string">
											<xs:attribute name="v" type="xs:float" use="required"/>
										</xs:extension>
									</xs:simpleContent>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attribute name="index" type="integerPositive"/>
					</xs:complexType>
				</xs:element>
				<xs:element ref="custom_attributes_list" minOccurs="0" maxOccurs="1"/>
				<xs:element ref="connection_1d_type" minOccurs="1" maxOccurs="1"/>
				<xs:element ref="contact_list" minOccurs="0" maxOccurs="1"/>
				<xs:element ref="appdata" minOccurs="0" maxOccurs="1"/>
			</xs:all>
			<xs:attribute name="label" type="xs:string"/>
			<xs:attribute name="quality_control" type="xs:string"/>
		</xs:complexType>
		<xs:unique name="uniqueLocListIndex">
			<xs:selector xpath="loc_list"/>
			<xs:field xpath="*/@index"/> 
		</xs:unique>
	</xs:element>
	<xs:element name="connection_1d_type" abstract="true"/>
	<xs:element name="seamweld" substitutionGroup="connection_1d_type">
		<xs:complexType>
			<xs:choice minOccurs="0" maxOccurs="1">
				<xs:element ref="butt_joint"/>
				<xs:element ref="corner_weld"/>
				<xs:element ref="edge_weld"/>
				<xs:element ref="i_weld"/>
				<xs:element ref="overlap_weld"/>
				<xs:element ref="y_joint"/>
				<xs:element ref="k_joint"/>
				<xs:element ref="cruciform_joint"/>
				<xs:element ref="flared_joint"/>
			</xs:choice>
		</xs:complexType>
	</xs:element>
	<xs:element name="butt_joint">
		<xs:complexType>
			<xs:all>
				<xs:element name="weld_position" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:attributeGroup ref="weld_position_common_attr"/>
						<xs:attribute name="section">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="I"/>
									<xs:enumeration value="V"/>
									<xs:enumeration value="U"/>
									<xs:enumeration value="X"/>
									<xs:enumeration value="Y"/>
									<xs:enumeration value="Radius"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute name="width" type="floatPositive"/>
						<xs:attribute name="filler">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="yes"/>
									<xs:enumeration value="no"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute name="filler_material" type="xs:string"/>
					</xs:complexType>
				</xs:element>
				<xs:element name="sheet_parameter" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:attribute name="index" type="xs:integer" use="required"/>
						<xs:attribute name="gap" type="floatZeroPositive"/>
						<xs:attribute name="sheet_thickness" type="floatPositive"/>
						<xs:attribute name="sheet_angle" type="xs:float"/>
					</xs:complexType>
				</xs:element>
			</xs:all>
			<xs:attribute name="base" type="integerPositive"/>
			<xs:attribute name="technology">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="resistance"/>
						<xs:enumeration value="arc"/>
						<xs:enumeration value="laser"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="corner_weld">
		<xs:complexType>
			<xs:all>
				<xs:element name="weld_position" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:attributeGroup ref="weld_position_common_attr"/>
						<xs:attribute name="section">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="U"/>
									<xs:enumeration value="HV"/>
									<xs:enumeration value="Fillet"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute name="thickness" type="floatPositive"/>
						<xs:attribute name="angle" type="xs:float"/>
						<xs:attribute name="filler">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="yes"/>
									<xs:enumeration value="no"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute name="filler_material" type="xs:string"/>
						<xs:attribute name="shape">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="straight"/>
									<xs:enumeration value="convex"/>
									<xs:enumeration value="concave"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute name="penetration">
							<xs:simpleType>
								<xs:restriction base="xs:float">
									<xs:minInclusive value="0"/>
									<xs:maxInclusive value="1"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
					</xs:complexType>
				</xs:element>
				<xs:element name="sheet_parameter" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:attribute name="index" type="xs:integer" use="required"/>
						<xs:attribute name="gap" type="floatZeroPositive"/>
						<xs:attribute name="sheet_thickness" type="floatPositive"/>
						<xs:attribute name="sheet_angle" type="xs:float"/>
					</xs:complexType>
				</xs:element>
			</xs:all>
			<xs:attribute name="base" type="integerPositive"/>
			<xs:attribute name="technology">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="resistance"/>
						<xs:enumeration value="arc"/>
						<xs:enumeration value="laser"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="edge_weld">
		<xs:complexType>
			<xs:all>
				<xs:element name="weld_position" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:attributeGroup ref="weld_position_common_attr"/>
						<xs:attribute name="section">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="I"/>
									<xs:enumeration value="V"/>
									<xs:enumeration value="U"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute name="width" type="floatPositive"/>
						<xs:attribute name="filler">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="yes"/>
									<xs:enumeration value="no"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute name="filler_material" type="xs:string"/>
					</xs:complexType>
				</xs:element>
				<xs:element name="sheet_parameter" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:attribute name="index" type="xs:integer" use="required"/>
						<xs:attribute name="gap" type="floatZeroPositive"/>
						<xs:attribute name="sheet_thickness" type="floatPositive"/>
						<xs:attribute name="sheet_angle" type="xs:float"/>
					</xs:complexType>
				</xs:element>
			</xs:all>
			<xs:attribute name="base" type="integerPositive"/>
			<xs:attribute name="technology">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="resistance"/>
						<xs:enumeration value="arc"/>
						<xs:enumeration value="laser"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="i_weld">
		<xs:complexType>
			<xs:all>
				<xs:element name="weld_position" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:attributeGroup ref="weld_position_common_attr"/>
						<xs:attribute name="width" type="floatPositive"/>
						<xs:attribute name="filler">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="yes"/>
									<xs:enumeration value="no"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute name="filler_material" type="xs:string"/>
					</xs:complexType>
				</xs:element>
				<xs:element name="sheet_parameter" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:attribute name="index" type="xs:integer" use="required"/>
						<xs:attribute name="gap" type="floatZeroPositive"/>
						<xs:attribute name="sheet_thickness" type="floatPositive"/>
						<xs:attribute name="sheet_angle" type="xs:float"/>
					</xs:complexType>
				</xs:element>
			</xs:all>
			<xs:attribute name="base" type="integerPositive"/>
			<xs:attribute name="technology">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="resistance"/>
						<xs:enumeration value="arc"/>
						<xs:enumeration value="laser"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="overlap_weld">
		<xs:complexType>
			<xs:all>
				<xs:element name="weld_position" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:attribute name="base" type="integerPositive"/>
						<xs:attributeGroup ref="weld_position_common_attr"/>
						<xs:attribute name="section">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="Fillet"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute name="thickness" type="floatPositive"/>
						<xs:attribute name="angle" type="xs:float"/>
						<xs:attribute name="filler">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="yes"/>
									<xs:enumeration value="no"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute name="filler_material" type="xs:string"/>
						<xs:attribute name="shape">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="straight"/>
									<xs:enumeration value="convex"/>
									<xs:enumeration value="concave"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute name="penetration">
							<xs:simpleType>
								<xs:restriction base="xs:float">
									<xs:minInclusive value="0"/>
									<xs:maxInclusive value="1"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
					</xs:complexType>
				</xs:element>
				<xs:element name="sheet_parameter" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:attribute name="index" type="xs:integer" use="required"/>
						<xs:attribute name="gap" type="floatZeroPositive"/>
						<xs:attribute name="sheet_thickness" type="floatPositive"/>
						<xs:attribute name="sheet_angle" type="xs:float"/>
					</xs:complexType>
				</xs:element>
			</xs:all>
			<xs:attribute name="base" type="integerPositive"/>
			<xs:attribute name="technology">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="resistance"/>
						<xs:enumeration value="arc"/>
						<xs:enumeration value="laser"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="y_joint">
		<xs:complexType>
			<xs:all>
				<xs:element name="weld_position" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:attribute name="base" type="integerPositive"/>
						<xs:attributeGroup ref="weld_position_common_attr"/>
						<xs:attribute name="section">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="HV"/>
									<xs:enumeration value="HY"/>
									<xs:enumeration value="Fillet"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute name="thickness" type="floatPositive"/>
						<xs:attribute name="angle" type="xs:float"/>
						<xs:attribute name="filler">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="yes"/>
									<xs:enumeration value="no"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute name="filler_material" type="xs:string"/>
						<xs:attribute name="shape">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="straight"/>
									<xs:enumeration value="convex"/>
									<xs:enumeration value="concave"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute name="penetration">
							<xs:simpleType>
								<xs:restriction base="xs:float">
									<xs:minInclusive value="0"/>
									<xs:maxInclusive value="1"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
					</xs:complexType>
				</xs:element>
				<xs:element name="sheet_parameter" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:attribute name="index" type="xs:integer" use="required"/>
						<xs:attribute name="gap" type="floatZeroPositive"/>
						<xs:attribute name="sheet_thickness" type="floatPositive"/>
						<xs:attribute name="sheet_angle" type="xs:float"/>
					</xs:complexType>
				</xs:element>
			</xs:all>
			<xs:attribute name="base" type="integerPositive"/>
			<xs:attribute name="technology">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="resistance"/>
						<xs:enumeration value="arc"/>
						<xs:enumeration value="laser"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="k_joint">
		<xs:complexType>
			<xs:all>
				<xs:element name="weld_position" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:attribute name="base" type="integerPositive"/>
						<xs:attributeGroup ref="weld_position_common_attr"/>
						<xs:attribute name="section">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="HV"/>
									<xs:enumeration value="HY"/>
									<xs:enumeration value="Fillet"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute name="thickness" type="floatPositive"/>
						<xs:attribute name="angle" type="xs:float"/>
						<xs:attribute name="filler">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="yes"/>
									<xs:enumeration value="no"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute name="filler_material" type="xs:string"/>
						<xs:attribute name="shape">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="straight"/>
									<xs:enumeration value="convex"/>
									<xs:enumeration value="concave"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute name="penetration">
							<xs:simpleType>
								<xs:restriction base="xs:float">
									<xs:minInclusive value="0"/>
									<xs:maxInclusive value="1"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
					</xs:complexType>
				</xs:element>
				<xs:element name="sheet_parameter" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:attribute name="index" type="xs:integer" use="required"/>
						<xs:attribute name="gap" type="floatZeroPositive" use="required"/>
						<xs:attribute name="sheet_thickness" type="floatPositive" use="required"/>
						<xs:attribute name="sheet_angle" type="xs:float" use="required"/>
					</xs:complexType>
				</xs:element>
			</xs:all>
			<xs:attribute name="base" type="integerPositive"/>
			<xs:attribute name="technology">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="resistance"/>
						<xs:enumeration value="arc"/>
						<xs:enumeration value="laser"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="cruciform_joint">
		<xs:complexType>
			<xs:all>
				<xs:element name="weld_position" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:attribute name="base" type="integerPositive"/>
						<xs:attributeGroup ref="weld_position_common_attr"/>
						<xs:attribute name="section">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="HV"/>
									<xs:enumeration value="HY"/>
									<xs:enumeration value="Fillet"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute name="thickness" type="floatPositive"/>
						<xs:attribute name="angle" type="xs:float"/>
						<xs:attribute name="filler">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="yes"/>
									<xs:enumeration value="no"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute name="filler_material" type="xs:string"/>
						<xs:attribute name="shape">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="straight"/>
									<xs:enumeration value="convex"/>
									<xs:enumeration value="concave"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute name="penetration">
							<xs:simpleType>
								<xs:restriction base="xs:float">
									<xs:minInclusive value="0"/>
									<xs:maxInclusive value="1"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
					</xs:complexType>
				</xs:element>
				<xs:element name="sheet_parameter" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:attribute name="index" type="xs:integer" use="required"/>
						<xs:attribute name="gap" type="floatZeroPositive" use="required"/>
						<xs:attribute name="sheet_thickness" type="floatPositive" use="required"/>
						<xs:attribute name="sheet_angle" type="xs:float" use="required"/>
					</xs:complexType>
				</xs:element>
			</xs:all>
			<xs:attribute name="base" type="integerPositive"/>
			<xs:attribute name="technology">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="resistance"/>
						<xs:enumeration value="arc"/>
						<xs:enumeration value="laser"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="flared_joint">
		<xs:complexType>
			<xs:all>
				<xs:element name="weld_position" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:attributeGroup ref="weld_position_common_attr"/>
						<xs:attribute name="width" type="floatPositive"/>
					</xs:complexType>
				</xs:element>
				<xs:element name="sheet_parameter" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:attribute name="index" type="xs:integer" use="required"/>
						<xs:attribute name="gap" type="floatZeroPositive"/>
						<xs:attribute name="sheet_thickness" type="floatPositive"/>
					</xs:complexType>
				</xs:element>
			</xs:all>
			<xs:attribute name="base" type="integerPositive"/>
			<xs:attribute name="technology">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="arc"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="adhesive_line" substitutionGroup="connection_1d_type">
		<xs:complexType>
			<xs:attribute name="base" type="integerPositive"/>
			<xs:attribute name="width" type="floatZeroPositive"/>
			<xs:attribute name="thickness" type="floatZeroPositive"/>
			<xs:attribute name="material" type="xs:string"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="hemming" substitutionGroup="connection_1d_type">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="region" minOccurs="0" maxOccurs="3"/>
			</xs:sequence>
			<xs:attribute name="folded_width" type="floatPositive"/>
			<xs:attribute name="folded_part" type="xs:integer"/>
			<xs:assert test="count(hemming/region[@label='A']) le 1"/>
			<xs:assert test="count(hemming/region[@label='B']) le 1"/>
			<xs:assert test="count(hemming/region[@label='C']) le 1"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="region">
		<xs:complexType>
			<xs:choice minOccurs="0" maxOccurs="1">
				<xs:element ref="connection_1d"/>
				<xs:element ref="connection_2d"/>
			</xs:choice>
			<xs:attribute name="label" use="required">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="A"/>
						<xs:enumeration value="B"/>
						<xs:enumeration value="C"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="fill_percentage">
				<xs:simpleType>
					<xs:restriction base="xs:float">
						<xs:minInclusive value="0"/>
						<xs:maxInclusive value="100"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:assert test="if( (@label eq 'A' or label eq 'C') and exists(connection_1d) and not(exists(connection_1d/adhesive_line))) then false() else true()"/>
			<xs:assert test="if( (@label eq 'A' or label eq 'C') and exists(connection_2d) and not(exists(connection_2d/adhesive_face))) then false() else true()"/>
			<xs:assert test="if( (@label eq 'B') and (exists(connection_1d) or exists(connection_2d)) ) then false() else true()"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="sequence_connection_0d" substitutionGroup="connection_1d_type">
		<xs:complexType>
			<xs:all>
				<xs:element ref="sequence_connection_0d_type" minOccurs="0" maxOccurs="1"/>
			</xs:all>
			<xs:attribute name="spacing" type="floatZeroPositive" use="required"/>
			<xs:attribute name="margin" type="floatZeroPositive" default="0.0"/>
			<xs:attribute name="priority" default="spacing">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="spacing"/>
						<xs:enumeration value="margin"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="sequence_connection_0d_type" abstract="true"/>
	<!-- ***************************************************************************************************************************************************************************** -->
	<xs:element name="connection_2d">
		<xs:complexType>
			<xs:all>
				<xs:element ref="adhesive_face" minOccurs="0" maxOccurs="1"/>
				<xs:element name="loc_list" minOccurs="1" maxOccurs="1">
					<xs:complexType>
						<xs:sequence>
							<xs:element name="loc" minOccurs="3" maxOccurs="unbounded">
								<xs:complexType>
									<xs:simpleContent>
										<xs:extension base="xs:string">
											<xs:attribute name="v" type="xs:integer" use="required"/>
										</xs:extension>
									</xs:simpleContent>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
				<xs:element ref="face_list" minOccurs="1" maxOccurs="1"/>
				<xs:element ref="appdata" minOccurs="0" maxOccurs="1"/>
				<xs:element ref="custom_attributes_list" minOccurs="0" maxOccurs="1"/>
			</xs:all>
			<xs:attribute name="label" type="xs:string"/>
			<xs:attribute name="quality_control" type="xs:string"/>
			<xs:assert test="every $x in face_list/face satisfies loc_list/loc[@v=$x/@v1]"/>
			<xs:assert test="every $x in face_list/face satisfies loc_list/loc[@v=$x/@v2]"/>
			<xs:assert test="every $x in face_list/face satisfies loc_list/loc[@v=$x/@v3]"/>
			<xs:assert test="every $x in face_list/face satisfies loc_list/loc[@v=$x/@v4]"/>
		</xs:complexType>
		<xs:unique name="vuq">
			<xs:selector xpath="loc_list/loc"/>
			<xs:field xpath="@v"/>
		</xs:unique>
	</xs:element>
	<xs:element name="adhesive_face">
		<xs:complexType>
			<xs:attribute name="base" type="integerPositive"/>
			<xs:attribute name="thickness" type="floatZeroPositive"/>
			<xs:attribute name="material" type="xs:string"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="face_list">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="face" minOccurs="1" maxOccurs="unbounded"/>
			</xs:sequence>
		</xs:complexType>
	</xs:element>
	<xs:element name="face">
		<xs:complexType>
			<xs:attribute name="v1" type="xs:integer" use="required"/>
			<xs:attribute name="v2" type="xs:integer" use="required"/>
			<xs:attribute name="v3" type="xs:integer" use="required"/>
			<xs:attribute name="v4" type="xs:integer" use="optional"/>
		</xs:complexType>
	</xs:element>
	<!-- ***************************************************************************************************************************************************************************** -->
	<xs:attributeGroup name="weld_position_common_attr">
		<xs:attribute name="u" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:float">
					<xs:minInclusive value="0"/>
					<xs:maxInclusive value="1"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="x" type="xs:float" use="required"/>
		<xs:attribute name="y" type="xs:float" use="required"/>
		<xs:attribute name="z" type="xs:float" use="required"/>
		<xs:attribute name="reference" type="xs:boolean" default="false"/>
	</xs:attributeGroup>
	<xs:simpleType name="integerPositive">
		<xs:restriction base="xs:integer">
			<xs:minExclusive value="0"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="floatPositive">
		<xs:restriction base="xs:float">
			<xs:minExclusive value="0.0"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="floatZeroPositive">
		<xs:restriction base="xs:float">
			<xs:minInclusive value="0.0"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="nonEmptyString">
		<xs:restriction base="xs:string">
			<xs:minLength value="1"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:element name="custom_attributes_list">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="custom_attributes" minOccurs="1" maxOccurs="unbounded"/>
			</xs:sequence>
		</xs:complexType>
		<xs:unique name="owner_for_unique">
			<xs:selector xpath="custom_attributes"/>
			<xs:field xpath="@owner"/>
			<xs:field xpath="@for"/>
		</xs:unique>
	</xs:element>
	<xs:element name="custom_attributes">
		<xs:complexType>
			<xs:choice minOccurs="1" maxOccurs="unbounded">
				<xs:element ref="string"/>
				<xs:element ref="real"/>
				<xs:element ref="int"/>
				<xs:element ref="string_list"/>
				<xs:element ref="real_list"/>
				<xs:element ref="int_list"/>
			</xs:choice>
			<xs:attribute name="owner" type="nonEmptyString" use="required"/>
			<xs:attribute name="for" type="nonEmptyString"/>
		</xs:complexType>
		<xs:unique name="stringKeyUq">
			<xs:selector xpath="string"/>
			<xs:field xpath="@key"/>
		</xs:unique>
		<xs:unique name="realKeyUq">
			<xs:selector xpath="real"/>
			<xs:field xpath="@key"/>
		</xs:unique>
		<xs:unique name="intKeyUq">
			<xs:selector xpath="int"/>
			<xs:field xpath="@key"/>
		</xs:unique>
		<xs:unique name="stringListKeyUq">
			<xs:selector xpath="string_list"/>
			<xs:field xpath="@key"/>
		</xs:unique>
		<xs:unique name="realListKeyUq">
			<xs:selector xpath="real_list"/>
			<xs:field xpath="@key"/>
		</xs:unique>
		<xs:unique name="intListKeyUq">
			<xs:selector xpath="int_list"/>
			<xs:field xpath="@key"/>
		</xs:unique>
	</xs:element>
	<xs:element name="string">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="xs:string">
					<xs:attribute name="key" type="nonEmptyString" use="required"/>
				</xs:extension>	
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="real">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="xs:float">
					<xs:attribute name="key" type="nonEmptyString" use="required"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="int">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="xs:int">
					<xs:attribute name="key" type="nonEmptyString" use="required"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="string_list">
		<xs:complexType>
			<xs:sequence>
				<xs:element name="value" minOccurs="1" maxOccurs="unbounded">
					<xs:complexType>
						<xs:simpleContent>
							<xs:extension base="xs:string">
								<xs:attribute name="index" type="integerPositive" use="required"/>
							</xs:extension>
						</xs:simpleContent>
					</xs:complexType>
				</xs:element>
			</xs:sequence>
			<xs:attribute name="key" type="nonEmptyString" use="required"/>
		</xs:complexType>
		<xs:unique name="stringListIndexUq">
			<xs:selector xpath="value"/>
			<xs:field xpath="@index"/>
		</xs:unique>
	</xs:element>
	<xs:element name="real_list">
		<xs:complexType>
			<xs:sequence>
				<xs:element name="value" minOccurs="1" maxOccurs="unbounded">
					<xs:complexType>
						<xs:simpleContent>
							<xs:extension base="xs:float">
								<xs:attribute name="index" type="integerPositive" use="required"/>
							</xs:extension>
						</xs:simpleContent>
					</xs:complexType>
				</xs:element>
			</xs:sequence>
			<xs:attribute name="key" type="nonEmptyString" use="required"/>
		</xs:complexType>
		<xs:unique name="realListIndexUq">
			<xs:selector xpath="value"/>
			<xs:field xpath="@index"/>
		</xs:unique>
	</xs:element>
	<xs:element name="int_list">
		<xs:complexType>
			<xs:sequence>
				<xs:element name="value" minOccurs="1" maxOccurs="unbounded">
					<xs:complexType>
						<xs:simpleContent>
							<xs:extension base="xs:int">
								<xs:attribute name="index" type="integerPositive" use="required"/>
							</xs:extension>
						</xs:simpleContent>
					</xs:complexType>
				</xs:element>
			</xs:sequence>
			<xs:attribute name="key" type="nonEmptyString" use="required"/>
		</xs:complexType>
		<xs:unique name="intListIndexUq">
			<xs:selector xpath="value"/>
			<xs:field xpath="@index"/>
		</xs:unique>
	</xs:element>
</xs:schema>
