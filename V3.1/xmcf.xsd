<?xml version="1.0"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:vc="http://www.w3.org/2007/XMLSchema-versioning" 
	xmlns:xerces="http://xerces.apache.org" elementFormDefault="qualified" vc:minVersion="1.1">
	<xs:element name="xmcf">
		<xs:complexType>
			<xs:all>
				<xs:element ref="units" minOccurs="0" maxOccurs="1"/>
				<xs:element name="date" type="xs:date" minOccurs="0" maxOccurs="1"/>
				<xs:element name="version" type="xs:string" minOccurs="1" maxOccurs="1"/>
				<xs:element ref="appdata" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="femdata" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="connection_group" minOccurs="0" maxOccurs="unbounded"/>
			</xs:all>

			<xs:assert test="if( (units/@angle='deg') and (exists(connection_group/connection_list/connection_0d/robscan[@orientation_angle lt -180.0]) )) then false() else true()"/>
			<xs:assert test="if( (units/@angle='deg') and (exists(connection_group/connection_list/connection_0d/robscan[@orientation_angle gt  180.0]) )) then false() else true()"/>

			<xs:assert test="if( ((units/@angle='rad') and (exists(connection_group/connection_list/connection_0d/robscan[@orientation_angle lt -3.14159265358979323846])))) then false() else true()"/>
			<xs:assert test="if( ((units/@angle='rad') and (exists(connection_group/connection_list/connection_0d/robscan[@orientation_angle gt  3.14159265358979323846])))) then false() else true()"/>


			<xs:assert test="if( (units/@angle='deg') and (exists(connection_group/connection_list/connection_1d/seamweld/*/sheet_parameter[@sheet_angle lt 0]))) then false() else true()"/>
			<xs:assert test="if( (units/@angle='deg') and (exists(connection_group/connection_list/connection_1d/seamweld/*/sheet_parameter[@sheet_angle gt 360]))) then false() else true()"/>

			<xs:assert test="if( (units/@angle='rad') and (exists(connection_group/connection_list/connection_1d/seamweld/*/sheet_parameter[@sheet_angle lt 0]))) then false() else true()"/>
			<xs:assert test="if( (units/@angle='rad') and (exists(connection_group/connection_list/connection_1d/seamweld/*/sheet_parameter[@sheet_angle gt 2*3.14159265358979323846]))) then false() else true()"/>

		</xs:complexType>
    
		<!-- connection_group/id must be unique within xmcf -->
		<xs:unique name="unique_connection_group_id">
			<xs:selector xpath="connection_group"/>
			<xs:field xpath="@id"/>
		</xs:unique>
	</xs:element>
	<xs:element name="units">
		<xs:complexType>
			<xs:attribute name="length" default="mm">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="mm"/>
						<xs:enumeration value="m"/>
						<xs:enumeration value="in"/>
						<xs:enumeration value="ft"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="angle" default="deg">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="deg"/>
						<xs:enumeration value="rad"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="mass" default="kg">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="g"/>
						<xs:enumeration value="kg"/>
						<xs:enumeration value="t"/>
						<xs:enumeration value="lb"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="force" default="N">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="kN"/>
						<xs:enumeration value="N"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="time" default="s">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="s"/>
						<xs:enumeration value="min"/>
						<xs:enumeration value="h"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="torque" default="Nm">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="Nm"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="appdata">
		<xs:complexType>
			<!-- 
				NOTE: We chose not to restrict the choice of elements under appdata, because the spec says:
				"The following list does not imply that other application names are forbidden. 
				Its noly purpose is to reserve the registered names against inappropriate use".
			-->
			<!--<xs:choice minOccurs="1" maxOccurs="unbounded">
				<xs:element name="ANSA"/>
				<xs:element name="FEMFAT"/>
				<xs:element name="HyperMesh"/>
				<xs:element name="LMSVirtualLab"/>
				<xs:element name="MEDINA"/>
				<xs:element name="NCODE"/>
				<xs:element name="SyncroFIT"/>
				<xs:any/>
			</xs:choice>-->
			<xs:sequence>
				<xs:any minOccurs="0" processContents="skip"/>
			</xs:sequence>
		</xs:complexType>
	</xs:element>
	<xs:element name="femdata">
		<xs:complexType>
			<!-- 
				NOTE: According to document, the following are the acceptable contents of femdata.
					  In case that more applications would be added, we should use commented code instead.
			-->
			<!--<xs:sequence>
				<xs:any minOccurs="0" processContents="skip"/>
			</xs:sequence>-->
			<xs:all>
				<xs:element name="PAMCRASH" minOccurs="0" maxOccurs="1">
					<xs:complexType>
						<xs:sequence>
							<xs:element ref="CAE_DATA" minOccurs="1" maxOccurs="unbounded"/>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
				<xs:element name="LSDYNA" minOccurs="0" maxOccurs="1">
					<xs:complexType>
						<xs:sequence>
							<xs:element ref="CAE_DATA" minOccurs="1" maxOccurs="unbounded"/>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
				<xs:element name="PERMAS" minOccurs="0" maxOccurs="1">
					<xs:complexType>
						<xs:sequence>
							<xs:element ref="CAE_DATA" minOccurs="1" maxOccurs="unbounded"/>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
				<xs:element name="ABAQUS" minOccurs="0" maxOccurs="1">
					<xs:complexType>
						<xs:sequence>
							<xs:element ref="CAE_DATA" minOccurs="1" maxOccurs="unbounded"/>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
				<xs:element name="RADIOSS" minOccurs="0" maxOccurs="1">
					<xs:complexType>
						<xs:sequence>
							<xs:element ref="CAE_DATA" minOccurs="1" maxOccurs="unbounded"/>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
				<xs:element name="OPTISTRUCT" minOccurs="0" maxOccurs="1">
					<xs:complexType>
						<xs:sequence>
							<xs:element ref="CAE_DATA" minOccurs="1" maxOccurs="unbounded"/>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
				<xs:element name="NASTRAN" minOccurs="0" maxOccurs="1">
					<xs:complexType>
						<xs:sequence>
							<xs:element ref="CAE_DATA" minOccurs="1" maxOccurs="unbounded"/>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
				<xs:element name="FEMFAT" minOccurs="0" maxOccurs="1">
					<xs:complexType>
						<xs:sequence>
							<xs:element ref="CAE_DATA" minOccurs="1" maxOccurs="unbounded"/>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
			</xs:all>
		</xs:complexType>
	</xs:element>
	<xs:element name="CAE_DATA">
		<xs:complexType>
			<xs:all>
				<xs:element name="REPRESENTATION" type="xs:string" minOccurs="0" maxOccurs="1"/>
				<xs:element name="COMMENT" type="xs:string" minOccurs="0" maxOccurs="1"/>
				<xs:element ref="CAE_PART_MEMBER" minOccurs="1" maxOccurs="unbounded"/>
			</xs:all>
			<xs:attribute name="VERSION" type="xs:integer" use="required"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="CAE_PART_MEMBER">
		<xs:complexType>
			<!-- NOTE: <any> is used in order to validate every schema. Alternatively, the following 
					   schema should be used or replaced with FATXML specification.
   			-->
			<!-- 
			<xs:sequence>
				<xs:element name="ENTITY" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:all>
							<xs:element name="TYPE" type="xs:string" minOccurs="1" maxOccurs="1"/>
							<xs:element name="ID" type="xs:string" minOccurs="1" maxOccurs="1"/>
						</xs:all>
					</xs:complexType>
				</xs:element>
			</xs:sequence>
			-->
			<xs:sequence>
				<xs:any minOccurs="0" processContents="skip"/>
			</xs:sequence>
			<xs:attribute name="ID" type="integerPositive"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="connection_group">
		<xs:complexType>
			<xs:all>
				<xs:element ref="connected_to" minOccurs="1" maxOccurs="1"/>			
				<xs:element ref="connection_list" minOccurs="1" maxOccurs="1"/>
				<xs:element ref="contact_list" minOccurs="0" maxOccurs="1"/>
				<xs:element ref="appdata" minOccurs="0" maxOccurs="1"/>
			</xs:all>
			<xs:attribute name="id" type="xs:int" use="required"/>
			<xs:assert test="if( exists(contact_list/contact/partner/@label) and not(every $x in contact_list/contact/partner/@label satisfies 
							( connected_to/part[@label=$x] or connected_to/assy/part[@label=$x] ) ) ) then false() else true()"/>
			<xs:assert test="if( exists(contact_list/contact/partner/@pid)   and not(every $x in contact_list/contact/partner/@pid satisfies 
							( connected_to/part[@pid=$x] or connected_to/assy/part[@pid=$x] ) ) ) then false() else true()"/>
			
			<xs:assert xerces:message="threaded_connection/contact_list/contact: index must be one of the indices defined in &lt;connected_to&gt;, but not the last one of them."
				test="every $x in connection_list/connection_0d/threaded_connection/contact_list/contact/@index
				satisfies $x ne max(connected_to/*/@index)"/>
		</xs:complexType>

		<xs:key name="connected_to_key">
			<xs:selector xpath="connected_to/*"/>
			<xs:field xpath="@index"/>
		</xs:key>
		<xs:keyref name="robscan_base_index" refer="connected_to_key">
			<xs:selector xpath="connection_list/connection_0d/robscan"/>
			<xs:field xpath="@base"/>
		</xs:keyref>
		<xs:keyref name="clipped_to_index" refer="connected_to_key">
			<xs:selector xpath="connection_list/connection_0d/threaded_connection/bolt"/>
			<xs:field xpath="@clipped_to"/>
		</xs:keyref>
		<xs:keyref name="fixed_to_index" refer="connected_to_key">
			<xs:selector xpath="connection_list/connection_0d/threaded_connection/bolt"/>
			<xs:field xpath="@fixed_to"/>
		</xs:keyref>
		<xs:keyref name="nut_clipped_to_index" refer="connected_to_key">
			<xs:selector xpath="connection_list/connection_0d/threaded_connection/bolt/nut"/>
			<xs:field xpath="@clipped_to"/>
		</xs:keyref>
		<xs:keyref name="nut_fixed_to_index" refer="connected_to_key">
			<xs:selector xpath="connection_list/connection_0d/threaded_connection/bolt/nut"/>
			<xs:field xpath="@fixed_to"/>
		</xs:keyref>
		<xs:keyref name="screw_base_index" refer="connected_to_key">
			<xs:selector xpath="connection_list/connection_0d/threaded_connection/screw"/>
			<xs:field xpath="@base"/>
		</xs:keyref>
		<xs:keyref name="pre_machined_hole_index" refer="connected_to_key">
			<xs:selector xpath="connection_list/connection_0d/threaded_connection/screw/flow_drilled"/>
			<xs:field xpath="@pre_machined_hole_index"/>
		</xs:keyref>
		<xs:keyref name="contact_list_index" refer="connected_to_key">
			<xs:selector xpath="connection_list/connection_0d/threaded_connection/contact_list/contact"/>
			<xs:field xpath="@index"/>
		</xs:keyref>
		<xs:keyref name="clip_clipped_to_index" refer="connected_to_key">
			<xs:selector xpath="connection_list/connection_0d/clip"/>
			<xs:field xpath="@clipped_to"/>
		</xs:keyref>
		<xs:keyref name="sheet_parameter_index" refer="connected_to_key">
			<!--sheet_parameter/index: "it must refer to <part> index attribute-->
			<xs:selector xpath="connection_list/connection_1d/seamweld/*/sheet_parameter"/>
			<xs:field xpath="@index"/>
		</xs:keyref>
		<xs:keyref name="seamweld_base_index" refer="connected_to_key">
			<xs:selector xpath="connection_list/connection_1d/seamweld/*"/>
			<xs:field xpath="@base"/>
		</xs:keyref>
		<xs:keyref name="folded_part_index" refer="connected_to_key">
			<xs:selector xpath="connection_list/connection_1d/hemming"/>
			<xs:field xpath="@folded_part"/>
		</xs:keyref>
		<xs:keyref name="hemming_top_part_index" refer="connected_to_key">
			<xs:selector xpath="connection_list/connection_1d/hemming/region"/>
			<xs:field xpath="@top_index"/>
		</xs:keyref>
		<xs:keyref name="hemming_bottom_part_index" refer="connected_to_key">
			<xs:selector xpath="connection_list/connection_1d/hemming/region"/>
			<xs:field xpath="@bottom_index"/>
		</xs:keyref>
		<xs:keyref name="adhesive_face_base" refer="connected_to_key">
			<xs:selector xpath="connection_list/connection_2d/adhesive_face"/>
			<xs:field xpath="@base"/>
		</xs:keyref>

	</xs:element>
	<xs:element name="contact_list">
		<xs:complexType>
			<xs:all>
				<xs:element name="contact" minOccurs="1" maxOccurs="unbounded">
					<xs:complexType>
						<xs:all>
							<xs:element ref="partner" minOccurs="2" maxOccurs="2"/>
							<xs:element ref="coefficients" minOccurs="1" maxOccurs="1"/>	
						</xs:all>
					</xs:complexType>
				</xs:element>
			</xs:all>
			<!-- 
				NOTE: "any set of physical contact partners must not appear more than once within a <contact_list>".
					      The first <xs:assert>, ensures that every pair of partners is distinct when it appears with the same
					  sequence. 
			          The second and commented <xs:assert>, ensures that every partners'pair is distinct irrespective of the sequence of partners. 
					  An extra check should be added for the case of the contact between one partner.
					  An extra check should be added for the case of pid is used instead of label.
			-->
			<xs:assert test="count(contact) eq count( distinct-values( contact/concat(partner[1]/@label, partner[2]/@label) ) )"/>
			<!--<xs:assert test="(count( distinct-values( contact/concat(partner[1]/@label, partner[2]/@label) ) ) + 
							  count( distinct-values( contact/concat(partner[2]/@label, partner[1]/@label) ) ) -
							  2 * count( distinct-values( contact/concat(partner[1]/@label, partner[1]/@label) ) )) eq 
							 (count( distinct-values( (contact/concat(partner[1]/@label, partner[2]/@label), contact/concat(partner[2]/@label, partner[1]/@label)) ) ) -
							  count( distinct-values( contact/concat(partner[1]/@label, partner[1]/@label) ) ) )"/>-->
		</xs:complexType>
	</xs:element>
	<xs:element name="connected_to">
		<xs:complexType>
			<xs:choice minOccurs="0" maxOccurs="unbounded">
				<xs:element name="part">
					<xs:complexType>
						<xs:attribute name="pid" type="integerPositive"/>
						<xs:attribute name="index" type="partIndex" use="required"/>
						<xs:attribute name="label" type="xs:string"/>
						
						<xs:assert test="exists(@label) or exists(@pid)"/>
						
					</xs:complexType>
				</xs:element>
				<xs:element name="assy">
					<xs:complexType>
						<xs:sequence>
							<xs:element name="part" minOccurs="2" maxOccurs="unbounded">
								<xs:complexType>
									<xs:attribute name="pid" type="integerPositive"/>
									<xs:attribute name="label" type="xs:string"/>
									
									<xs:assert test="exists(@label) or exists(@pid)"/>

								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attribute name="index" type="partIndex" use="required"/>
					</xs:complexType>
				</xs:element>
			</xs:choice>
		</xs:complexType>
		<xs:unique name="unique_index_in_part_and_assy">
			<xs:selector xpath="./*"/>
			<xs:field xpath="@index"/>
		</xs:unique>
	</xs:element>
	<xs:element name="partner">
		<xs:complexType>
			<xs:attribute name="label" type="xs:string"/>
			<xs:attribute name="pid" type="integerPositive"/>
			<xs:assert test="exists(@label) or exists(@pid)"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="coefficients">
		<xs:complexType>
			<xs:attribute name="static_friction" type="floatZeroPositive"/>
			<xs:attribute name="kinetic_friction" type="floatZeroPositive"/>
			<xs:assert test="exists(@static_friction) or exists(@kinetic_friction)"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="connection_list">
		<xs:complexType>
			<xs:choice minOccurs="1" maxOccurs="unbounded">
				<xs:element ref="connection_0d"/>
				<xs:element ref="connection_1d"/>
				<xs:element ref="connection_2d"/>
			</xs:choice>
		</xs:complexType>
	</xs:element>

	<!-- ***************************************************************************************************************************************************************** -->
	<xs:element name="connection_0d">
		<xs:complexType>
			<xs:all>
				<xs:element name="loc" type="xs:string" minOccurs="1" maxOccurs="1"/>
				<xs:element ref="appdata" minOccurs="0" maxOccurs="1"/>
				<xs:element ref="femdata" minOccurs="0" maxOccurs="1"/>
				<xs:element ref="custom_attributes_list" minOccurs="0" maxOccurs="1"/>
				<xs:element ref="connection_0d_type" minOccurs="1" maxOccurs="1"/> <!--"Note: exactly one of the type elements must exist in <connection_od>. There is no default type"-->
			</xs:all>
			<xs:attribute name="label" type="xs:string"/>
			<xs:attribute name="quality_control" type="xs:string"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="connection_0d_type" abstract="true"/>
	<xs:element name="normal_direction">
		<xs:complexType>
			<xs:attribute name="x" type="xs:float" use="required"/>
			<xs:attribute name="y" type="xs:float" use="required"/>
			<xs:attribute name="z" type="xs:float" use="required"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="tangential_direction">
		<xs:complexType>
			<xs:attribute name="x" type="xs:float" use="required"/>
			<xs:attribute name="y" type="xs:float" use="required"/>
			<xs:attribute name="z" type="xs:float" use="required"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="spotweld" substitutionGroup="connection_0d_type sequence_connection_0d_type">
		<xs:complexType>
			<xs:attribute name="diameter" type="floatPositive"/>
			<xs:attribute name="technology">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="resistance"/>
						<xs:enumeration value="laser"/>
						<xs:enumeration value="projection"/>
						<xs:enumeration value="friction"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="robscan" substitutionGroup="connection_0d_type">
		<xs:complexType>
			<xs:all>
				<xs:element ref="normal_direction" minOccurs="0" maxOccurs="1"/>
				<xs:element ref="tangential_direction" minOccurs="0" maxOccurs="1"/>
			</xs:all>
			<xs:attribute name="base" type="partIndex"/>
			<xs:attribute name="pattern" type="nonEmptyString"/>
			<xs:attribute name="gap" type="floatZeroPositive"/>
			<xs:attribute name="width" type="floatPositive"/>
			<xs:attribute name="pattern_width" type="floatPositive"/>
			<xs:attribute name="pattern_length" type="floatPositive"/>
			<xs:attribute name="mirrored" type="xs:boolean" default="false"/>
			<xs:attribute name="orientation_angle" type="xs:float"/>
			<xs:attribute name="filler_material" type="xs:string"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="rivet" substitutionGroup="connection_0d_type">
		<xs:complexType>
			<xs:all>
				<xs:element ref="normal_direction" minOccurs="0" maxOccurs="1"/>
				<xs:element ref="rivet_type" minOccurs="0" maxOccurs="1"/>
			</xs:all>
			<xs:attribute name="shaft_diameter" type="floatPositive"/>
			<xs:attribute name="length" type="floatPositive"/>
			<xs:attribute name="head_diameter" type="floatPositive"/>
			<xs:attribute name="head_height" type="floatZeroPositive"/>
			<xs:attribute name="head_type" type="xs:string"/>
			<xs:attribute name="sink_size" type="floatZeroPositive"/>
			<xs:attribute name="strength_property_class" type="xs:string"/>
			<xs:attribute name="part_code" type="xs:string"/>

			<xs:assert xerces:message="rivet: it must hold that (head_height + sink_size) > 0"
				test="
				if (exists(@head_height) and exists(@sink_size)) 
				then (sum(@head_height + @sink_size) gt 0) 
				else true()"/>
			<xs:assert xerces:message="rivet: it must hold that (head_height + sink_size) > 0"
				test="
				if (exists(@head_height) and not(exists(@sink_size))) 
				then (@head_height gt 0) 
				else true()"/>
			<xs:assert xerces:message="rivet: it must hold that (head_height + sink_size) > 0"
				test="
				if (not(exists(@head_height)) and exists(@sink_size)) 
				then (@sink_size gt 0) 
				else true()"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="rivet_type" abstract="true"/>
	<xs:element name="blind" substitutionGroup="rivet_type">
		<xs:complexType>
			<xs:attribute name="min_grip" type="floatPositive"/>
			<xs:attribute name="max_grip" type="floatPositive"/>
			<xs:attribute name="clearance" type="floatPositive"/>
			<xs:attribute name="material" type="xs:string"/>

			<xs:assert 
				xerces:message="rivet/blind: rule is max grip >= min_grip"
				test="if (exists(@max_grip) and exists(@min_grip)) then (@max_grip ge @min_grip) else true()"/>

		</xs:complexType>
	</xs:element>
	<xs:element name="self_piercing" substitutionGroup="rivet_type">
		<xs:complexType>
			<xs:attribute name="hardness" type="floatPositive"/>
			<xs:attribute name="head_label" type="xs:string"/>
			<xs:attribute name="shaft_label" type="xs:string"/>
			<xs:attribute name="die_label" type="xs:string"/>
			<xs:attribute name="die_diameter" type="floatPositive"/>
			<xs:attribute name="die_depth" type="floatPositive"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="solid" substitutionGroup="rivet_type">
		<xs:complexType>
			<xs:attribute name="min_grip" type="floatPositive"/>
			<xs:attribute name="max_grip" type="floatPositive"/>
			<xs:attribute name="hole_diameter" type="floatPositive"/>
			<xs:attribute name="hole_depth" type="floatPositive"/>
			<xs:attribute name="shoulder_diameter" type="floatPositive"/>
			<xs:attribute name="shoulder_length" type="floatPositive"/>
			<xs:attribute name="tennon_diameter" type="floatPositive"/>
			<xs:attribute name="tennon_length" type="floatPositive"/>
			
			<xs:assert 
				xerces:message="rivet/solid: rule is max grip >= min_grip"
				test="if (exists(@max_grip) and exists(@min_grip)) then (@max_grip ge @min_grip) else true()"/>

			<!--The following are Recommendations:
				"1. hole_diameter is defined with hole_depth and vice versa"
				"2. tennon_diameter exist only if shoulder_diameter is defined and vice versa"
				Therefore they were commented out
			-->
			<!--<xs:assert test="if( ( exists(@hole_diameter) and exists(@hole_depth) ) or ( not(exists(@hole_diameter)) and not(exists(@hole_depth)) ) ) then true() else false()"/>-->
			<!--<xs:assert test="if( ( exists(@tennon_diameter) and exists(@shoulder_diameter) ) or ( not(exists(@tennon_diameter)) and not(exists(@shoulder_diameter)) ) ) then true() else false()"/>-->
    </xs:complexType>
	</xs:element>
	<xs:element name="swop" substitutionGroup="rivet_type">
		<xs:complexType>
			<xs:attribute name="insert_shape" type="xs:string"/>
			<xs:attribute name="insert_height" type="floatPositive"/>
			<xs:attribute name="spotweld_diameter" type="floatPositive"/>
			<xs:attribute name="spotweld_technology">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="resistance"/>
						<xs:enumeration value="laser"/>
						<xs:enumeration value="projection"/>
						<xs:enumeration value="friction"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="threaded_connection" substitutionGroup="connection_0d_type">
		<xs:complexType>
			<xs:all>
				<xs:element ref="normal_direction" minOccurs="0" maxOccurs="1"/>
				<xs:element ref="threaded_connection_type" minOccurs="1" maxOccurs="1"/>
				<xs:element ref="washer" minOccurs="0" maxOccurs="1"/>
				<xs:element name="contact_list" minOccurs="0" maxOccurs="1">
					<xs:complexType>
						<xs:all>
							<xs:element name="contact" minOccurs="1" maxOccurs="unbounded">
								<xs:complexType>
									<xs:attribute name="index" type="partIndex"/>
									<xs:attribute name="thread" type="xs:boolean" default="false"/>
									<xs:attribute name="static_friction" type="floatPositive"/>
									<xs:attribute name="kinetic_friction" type="floatPositive"/>
                  
									<xs:assert
										xerces:message="threaded_connection/contact_list/contact: At least one of the two friction coefficients has to be specified"
										test="exists(@static_friction) or exists(@kinetic_friction)"/>

									<xs:assert
										xerces:message="threaded_connection/contact_list/contact: index is required if thread is not 'true'"
										test="@thread=true() or exists(@index)"/>
								</xs:complexType>
							</xs:element>
						</xs:all>

						<xs:assert xerces:message=" there can be up to 1 contact with the thread "
							test="count(contact[@thread=true()]) le 1"/>
					</xs:complexType>
          
					<xs:unique name="unique_contact_index_in_contact_list">
						<!--threaded_connection/contact/index: "any specific index may occur not more than once".-->
						<xs:selector xpath="contact"/>
						<xs:field xpath="@index"/>
					</xs:unique>
				</xs:element>
			</xs:all>
			<xs:attribute name="diameter" type="floatZeroPositive"/>
			<xs:attribute name="length" type="floatPositive"/>
			<xs:attribute name="thread_length" type="floatPositive"/>
			<xs:attribute name="head_diameter" type="floatPositive"/>
			<xs:attribute name="head_height" type="floatZeroPositive"/>
			<xs:attribute name="head_type" type="xs:string"/>
			<xs:attribute name="sink_size" type="floatZeroPositive"/>
			<xs:attribute name="pitch" type="floatPositive"/>
			<xs:attribute name="lead" type="floatPositive"/>
			<xs:attribute name="torque" type="floatPositive"/>
			<xs:attribute name="angle" type="floatPositive"/>
			<xs:attribute name="pretension" type="floatPositive"/>
			<xs:attribute name="static_friction" type="floatPositive"/>
			<xs:attribute name="kinetic_friction" type="floatPositive"/>
			<xs:attribute name="strength_property_class" type="xs:string"/>
			<xs:attribute name="part_code" type="xs:string"/>
      
			<xs:assert 
				xerces:message="it must hold that length >= thread_length"
				test="if (@length lt @thread_length) then false() else true()" />

		</xs:complexType>
	</xs:element>
	<xs:element name="threaded_connection_type" abstract="true"/>
	<xs:element name="washer">
		<xs:complexType>
			<xs:attribute name="outer_diameter" type="floatPositive"/>
			<xs:attribute name="inner_diameter" type="floatPositive"/>
			<xs:attribute name="thickness" type="floatPositive"/>
			<xs:attribute name="attached" type="xs:boolean" default="false"/>
			<xs:attribute name="static_friction" type="floatPositive"/>
			<xs:attribute name="kinetic_friction" type="floatPositive"/>
			<xs:attribute name="strength_property_class" type="xs:string"/>
			<xs:attribute name="part_code" type="xs:string"/>
      
			<xs:assert 
				xerces:message="threaded_connection/washer: NO part code, if attached"
				test="if (@attached = true() and exists(@part_code)) then false() else true()"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="nut">
		<xs:complexType>
			<xs:all>
				<xs:element ref="washer" minOccurs="0" maxOccurs="1"/>
			</xs:all>
			<xs:attribute name="diameter" type="floatPositive"/>
			<xs:attribute name="height" type="floatPositive"/>
			<xs:attribute name="torque" type="floatPositive"/>
			<xs:attribute name="angle" type="floatPositive"/>
			<xs:attribute name="static_friction" type="floatPositive"/>
			<xs:attribute name="kinetic_friction" type="floatPositive"/>
			<xs:attribute name="clipped_to" type="partIndex"/>
			<xs:attribute name="fixed_to" type="partIndex"/>
			<xs:attribute name="strength_property_class" type="xs:string"/>
			<xs:attribute name="part_code" type="xs:string"/>
      
			<xs:assert
				xerces:message="bolt/nut: nut fixed_to prohibits nut clipped_to and vice versa"
				test="not (exists(@fixed_to) and exists(@clipped_to))"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="bolt" substitutionGroup="threaded_connection_type">
		<xs:complexType>
			<xs:all>
				<xs:element ref="nut" minOccurs="0" maxOccurs="1"/>
			</xs:all>
			<xs:attribute name="clipped_to" type="partIndex"/>
			<xs:attribute name="fixed_to" type="partIndex"/>

			<xs:assert 
				xerces:message="bolt fixed_to prohibits bolt clipped_to and vice versa"
				test="not (exists(@fixed_to) and exists(@clipped_to))"/>

			<xs:assert 
				xerces:message="nut clipped_to or fixed_to prohibits bolt clipped_to or fixed_to and vice versa"
				test="not ((exists(nut/@fixed_to) or exists(nut/@clipped_to)) and (exists(@fixed_to) or exists(@clipped_to)))"/>

		</xs:complexType>
	</xs:element>
	<xs:element name="screw" substitutionGroup="threaded_connection_type">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="flow_drilled" minOccurs="0" maxOccurs="unbounded"/>
			</xs:sequence>
			<xs:attribute name="base" type="partIndex"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="flow_drilled">
		<xs:complexType>
			<xs:attribute name="pre_machined_hole_diameter" type="floatZeroPositive"/>
			<xs:attribute name="pre_machined_hole_index" type="partIndex"/>
			<xs:attribute name="pilot_hole_diameter" type="floatZeroPositive"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="gumdrop" substitutionGroup="connection_0d_type sequence_connection_0d_type">
		<xs:complexType>
			<xs:attribute name="diameter" type="floatZeroPositive"/>
			<xs:attribute name="mass" type="floatZeroPositive"/>
			<xs:attribute name="material" type="xs:string"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="clinch" substitutionGroup="connection_0d_type">
		<xs:complexType>
			<xs:all>
				<xs:element ref="normal_direction" minOccurs="0" maxOccurs="1"/>
			</xs:all>
			<xs:attribute name="clinch_type" type="xs:string"/>
			<xs:attribute name="strength_class" type="xs:string"/>
			<xs:attribute name="shear_strength" type="floatPositive"/>
			<xs:attribute name="peel_strength" type="floatPositive"/>
			<xs:attribute name="button_diameter" type="floatPositive"/>
			<xs:attribute name="die_type">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="round"/>
						<xs:enumeration value="rectangular"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="heat_stake" substitutionGroup="connection_0d_type">
		<xs:complexType>
			<xs:all>
				<xs:element ref="normal_direction" minOccurs="0" maxOccurs="1"/>
			</xs:all>
			<xs:attribute name="heat_stake_type" type="xs:string"/>
			<xs:attribute name="strength" type="floatPositive"/>
			<xs:attribute name="diameter" type="floatPositive"/>
			<xs:attribute name="head_diameter" type="floatPositive"/>
			<xs:attribute name="head_height" type="floatZeroPositive"/>
			<xs:attribute name="void_diameter" type="floatZeroPositive"/>
			<xs:attribute name="hole_diameter" type="floatPositive"/>

			<xs:assert 
				xerces:message="heat_stake: it must hold that hole_diameter > diameter"
				test="if (exists(@diameter) and exists(@hole_diameter)) 
				then (@diameter lt @hole_diameter)
				else true()"/>
			<xs:assert
				xerces:message="heat_stake: it must hold that diameter > void_diameter"
				test="if (exists(@void_diameter) and exists(@diameter))
				then (@void_diameter lt @diameter)
				else true()"/>
			<xs:assert 
				xerces:message="heat_stake: it must hold that head_diameter > hole_diameter"
				test="if (exists(@hole_diameter) and exists(@head_diameter))
				then (@hole_diameter lt @head_diameter)
				else true()"/>
			<xs:assert 
				xerces:message="heat_stake: it must hold that head_diameter > diameter"
				test="if (exists(@diameter) and exists(@head_diameter))
				then (@diameter lt @head_diameter)
				else true()"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="clip" substitutionGroup="connection_0d_type">
		<xs:complexType>
			<xs:all>
				<xs:element ref="normal_direction" minOccurs="0" maxOccurs="1"/>
				<xs:element ref="tangential_direction" minOccurs="0" maxOccurs="1"/>
			</xs:all>
			<xs:attribute name="clip_type" type="xs:string"/>
			<xs:attribute name="attachment_type" type="xs:string"/>
			<xs:attribute name="hole_diameter" type="floatZeroPositive"/>
			<xs:attribute name="hole_length" type="floatZeroPositive"/>
			<xs:attribute name="pin_diameter" type="floatZeroPositive"/>
			<xs:attribute name="pin_width" type="floatZeroPositive"/>
			<xs:attribute name="pin_length" type="floatZeroPositive"/>
			<xs:attribute name="strap_length" type="floatZeroPositive"/>
			<xs:attribute name="clipped_to" type="partIndex"/>
			<xs:attribute name="material" type="xs:string"/>
			<xs:attribute name="part_code" type="xs:string"/>

			<xs:assert 
				xerces:message="hole_length > 0 implies hole_diameter > 0"
				test="if (@hole_length gt 0 and @hole_diameter = 0) then false() else true()"/>
			<xs:assert 
				xerces:message="pin_width > 0 implies pin_diameter > 0"
				test="if (@pin_width gt 0 and @pin_diameter = 0) then false() else true()"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="nail" substitutionGroup="connection_0d_type">
		<xs:complexType>
			<xs:all>
				<xs:element ref="normal_direction" minOccurs="0" maxOccurs="1"/>
				<xs:element ref="tangential_direction" minOccurs="0" maxOccurs="1"/>
			</xs:all>
			<xs:attribute name="nail_type" type="xs:string"/>
			<xs:attribute name="shaft_diameter" type="floatPositive"/>
			<xs:attribute name="length" type="floatPositive"/>
			<xs:attribute name="cylinder_length" type="floatPositive"/>
			<xs:attribute name="head_diameter" type="floatPositive"/>
			<xs:attribute name="head_height" type="floatPositive"/>
			<xs:attribute name="shear_strength" type="floatPositive"/>
			<xs:attribute name="peel_strength" type="floatPositive"/>
			<xs:attribute name="material" type="xs:string"/>
			<xs:attribute name="part_code" type="xs:string"/>
		</xs:complexType>
	</xs:element>
	<!-- ************************************************************************************************************************************************************* -->
	<xs:element name="connection_1d">
		<xs:complexType>
			<xs:all>
				<xs:element name="loc_list" minOccurs="1" maxOccurs="unbounded">
					<xs:complexType>
						<xs:sequence>
							<xs:element name="loc" minOccurs="1" maxOccurs="unbounded">
								<xs:complexType>
									<xs:simpleContent>
										<xs:extension base="xs:string">
											<xs:attribute name="v" type="xs:float" use="required"/>
										</xs:extension>
									</xs:simpleContent>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attribute name="index" type="integerPositive"/>
					</xs:complexType>
					<xs:unique name="unique_v_in_connection_1d_loc_list">
						<xs:selector xpath="loc"/>
						<xs:field xpath="@v"/>
					</xs:unique>
				</xs:element>
				<xs:element ref="custom_attributes_list" minOccurs="0" maxOccurs="1"/>
				<xs:element ref="connection_1d_type" minOccurs="1" maxOccurs="1"/>
				<xs:element ref="contact_list" minOccurs="0" maxOccurs="1"/>
				<xs:element ref="appdata" minOccurs="0" maxOccurs="1"/>
				<xs:element ref="femdata" minOccurs="0" maxOccurs="1"/>
			</xs:all>
			<xs:attribute name="label" type="xs:string"/>
			<xs:attribute name="quality_control" type="xs:string"/>

			<xs:assert xerces:message="connection_1d/loc_list: index must exist if more that 1 loc_list elements exist"
				test="(count(loc_list) le 1)  or  count(loc_list[@index>0]) = count(loc_list)" />

		</xs:complexType>
		<xs:unique name="unique_loc_list_index">
			<xs:selector xpath="loc_list"/>
			<xs:field xpath="@index"/> 
		</xs:unique>
	</xs:element>
	<xs:element name="connection_1d_type" abstract="true"/>
	<xs:element name="seamweld" substitutionGroup="connection_1d_type">
		<xs:complexType>
			<xs:choice minOccurs="0" maxOccurs="1">
				<xs:element ref="butt_joint"/>
				<xs:element ref="corner_weld"/>
				<xs:element ref="edge_weld"/>
				<xs:element ref="i_weld"/>
				<xs:element ref="overlap_weld"/>
				<xs:element ref="y_joint"/>
				<xs:element ref="k_joint"/>
				<xs:element ref="cruciform_joint"/>
				<xs:element ref="flared_joint"/>
			</xs:choice>
		</xs:complexType>
	</xs:element>

	<xs:element name="butt_joint">
		<xs:complexType>
			<xs:all>
				<xs:element name="weld_position" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:attributeGroup ref="weld_position_common_attr"/>
						<xs:attribute name="section">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="I"/>
									<xs:enumeration value="V"/>
									<xs:enumeration value="U"/>
									<xs:enumeration value="X"/>
									<xs:enumeration value="Y"/>
									<xs:enumeration value="Radius"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute name="width" type="floatPositive"/>
						<xs:attribute name="filler">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="yes"/>
									<xs:enumeration value="no"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute name="filler_material" type="xs:string"/>
					</xs:complexType>
				</xs:element>
				<xs:element name="sheet_parameter" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:attribute name="index" type="partIndex" use="required"/>
						<xs:attribute name="gap" type="floatZeroPositive"/>
						<xs:attribute name="sheet_thickness" type="floatPositive"/>
						<xs:attribute name="sheet_angle" type="xs:float"/>
					</xs:complexType>
				</xs:element>
			</xs:all>
			<xs:attribute name="base" type="partIndex"/>
			<xs:attribute name="technology">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="resistance"/>
						<xs:enumeration value="arc"/>
						<xs:enumeration value="laser"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>

		<xs:unique name="unique_index_in_butt_joint_sheet_parameter">
			<xs:selector xpath="sheet_parameter"/>
			<xs:field xpath="@index"/>
		</xs:unique>

	</xs:element>
	<xs:element name="corner_weld">
		<xs:complexType>
			<xs:all>
				<xs:element name="weld_position" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:attributeGroup ref="weld_position_common_attr"/>
						<xs:attribute name="section">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="U"/>
									<xs:enumeration value="HV"/>
									<xs:enumeration value="Fillet"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute name="thickness" type="floatPositive"/>
						<xs:attribute name="angle" type="xs:float"/>
						<xs:attribute name="filler">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="yes"/>
									<xs:enumeration value="no"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute name="filler_material" type="xs:string"/>
						<xs:attribute name="shape">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="straight"/>
									<xs:enumeration value="convex"/>
									<xs:enumeration value="concave"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute name="penetration">
							<xs:simpleType>
								<xs:restriction base="xs:float">
									<xs:minInclusive value="0"/>
									<xs:maxInclusive value="1"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
					</xs:complexType>
				</xs:element>
				<xs:element name="sheet_parameter" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:attribute name="index" type="partIndex" use="required"/>
						<xs:attribute name="gap" type="floatZeroPositive"/>
						<xs:attribute name="sheet_thickness" type="floatPositive"/>
						<xs:attribute name="sheet_angle" type="xs:float"/>
					</xs:complexType>
				</xs:element>
			</xs:all>
			<xs:attribute name="base" type="partIndex"/>
			<xs:attribute name="technology">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="resistance"/>
						<xs:enumeration value="arc"/>
						<xs:enumeration value="laser"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>

		<xs:unique name="unique_index_in_corner_weld_sheet_parameter">
			<xs:selector xpath="sheet_parameter"/>
			<xs:field xpath="@index"/>
		</xs:unique>

	</xs:element>
	<xs:element name="edge_weld">
		<xs:complexType>
			<xs:all>
				<xs:element name="weld_position" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:attributeGroup ref="weld_position_common_attr"/>
						<xs:attribute name="section">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="I"/>
									<xs:enumeration value="V"/>
									<xs:enumeration value="U"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute name="width" type="floatPositive"/>
						<xs:attribute name="filler">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="yes"/>
									<xs:enumeration value="no"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute name="filler_material" type="xs:string"/>
					</xs:complexType>
				</xs:element>
				<xs:element name="sheet_parameter" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:attribute name="index" type="partIndex" use="required"/>
						<xs:attribute name="gap" type="floatZeroPositive"/>
						<xs:attribute name="sheet_thickness" type="floatPositive"/>
						<xs:attribute name="sheet_angle" type="xs:float"/>
					</xs:complexType>
				</xs:element>
			</xs:all>
			<xs:attribute name="base" type="partIndex"/>
			<xs:attribute name="technology">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="resistance"/>
						<xs:enumeration value="arc"/>
						<xs:enumeration value="laser"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>

		<xs:unique name="unique_index_in_edge_weld_sheet_parameter">
			<xs:selector xpath="sheet_parameter"/>
			<xs:field xpath="@index"/>
		</xs:unique>

	</xs:element>
	<xs:element name="i_weld">
		<xs:complexType>
			<xs:all>
				<xs:element name="weld_position" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:attributeGroup ref="weld_position_common_attr"/>
						<xs:attribute name="width" type="floatPositive"/>
						<xs:attribute name="filler">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="yes"/>
									<xs:enumeration value="no"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute name="filler_material" type="xs:string"/>
					</xs:complexType>
				</xs:element>
				<xs:element name="sheet_parameter" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:attribute name="index" type="partIndex" use="required"/>
						<xs:attribute name="gap" type="floatZeroPositive"/>
						<xs:attribute name="sheet_thickness" type="floatPositive"/>
						<xs:attribute name="sheet_angle" type="xs:float"/>
					</xs:complexType>
				</xs:element>
			</xs:all>
			<xs:attribute name="base" type="partIndex"/>
			<xs:attribute name="technology">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="resistance"/>
						<xs:enumeration value="arc"/>
						<xs:enumeration value="laser"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>

		<xs:unique name="unique_index_in_i_weld_sheet_parameter">
			<xs:selector xpath="sheet_parameter"/>
			<xs:field xpath="@index"/>
		</xs:unique>

	</xs:element>
	<xs:element name="overlap_weld">
		<xs:complexType>
			<xs:all>
				<xs:element name="weld_position" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:attribute name="base" type="partIndex"/>
						<xs:attributeGroup ref="weld_position_common_attr"/>
						<xs:attribute name="section">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="Fillet"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute name="thickness" type="floatPositive"/>
						<xs:attribute name="angle" type="xs:float"/>
						<xs:attribute name="filler">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="yes"/>
									<xs:enumeration value="no"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute name="filler_material" type="xs:string"/>
						<xs:attribute name="shape">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="straight"/>
									<xs:enumeration value="convex"/>
									<xs:enumeration value="concave"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute name="penetration">
							<xs:simpleType>
								<xs:restriction base="xs:float">
									<xs:minInclusive value="0"/>
									<xs:maxInclusive value="1"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
					</xs:complexType>
				</xs:element>
				<xs:element name="sheet_parameter" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:attribute name="index" type="partIndex" use="required"/>
						<xs:attribute name="gap" type="floatZeroPositive"/>
						<xs:attribute name="sheet_thickness" type="floatPositive"/>
						<xs:attribute name="sheet_angle" type="xs:float"/>
					</xs:complexType>
				</xs:element>
			</xs:all>
			<xs:attribute name="base" type="partIndex"/>
			<xs:attribute name="technology">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="resistance"/>
						<xs:enumeration value="arc"/>
						<xs:enumeration value="laser"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>

		<xs:unique name="unique_index_in_overlap_weld_sheet_parameter">
			<xs:selector xpath="sheet_parameter"/>
			<xs:field xpath="@index"/>
		</xs:unique>

	</xs:element>
	<xs:element name="y_joint">
		<xs:complexType>
			<xs:all>
				<xs:element name="weld_position" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:attribute name="base" type="partIndex"/>
						<xs:attributeGroup ref="weld_position_common_attr"/>
						<xs:attribute name="section">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="HV"/>
									<xs:enumeration value="HY"/>
									<xs:enumeration value="Fillet"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute name="thickness" type="floatPositive"/>
						<xs:attribute name="angle" type="xs:float"/>
						<xs:attribute name="filler">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="yes"/>
									<xs:enumeration value="no"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute name="filler_material" type="xs:string"/>
						<xs:attribute name="shape">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="straight"/>
									<xs:enumeration value="convex"/>
									<xs:enumeration value="concave"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute name="penetration">
							<xs:simpleType>
								<xs:restriction base="xs:float">
									<xs:minInclusive value="0"/>
									<xs:maxInclusive value="1"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
					</xs:complexType>
				</xs:element>
				<xs:element name="sheet_parameter" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:attribute name="index" type="partIndex" use="required"/>
						<xs:attribute name="gap" type="floatZeroPositive"/>
						<xs:attribute name="sheet_thickness" type="floatPositive"/>
						<xs:attribute name="sheet_angle" type="xs:float"/>
					</xs:complexType>
				</xs:element>
			</xs:all>
			<xs:attribute name="base" type="partIndex"/>
			<xs:attribute name="technology">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="resistance"/>
						<xs:enumeration value="arc"/>
						<xs:enumeration value="laser"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>

		<xs:unique name="unique_index_in_y_joint_sheet_parameter">
			<xs:selector xpath="sheet_parameter"/>
			<xs:field xpath="@index"/>
		</xs:unique>

	</xs:element>
	<xs:element name="k_joint">
		<xs:complexType>
			<xs:all>
				<xs:element name="weld_position" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:attribute name="base" type="partIndex"/>
						<xs:attributeGroup ref="weld_position_common_attr"/>
						<xs:attribute name="section">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="HV"/>
									<xs:enumeration value="HY"/>
									<xs:enumeration value="Fillet"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute name="thickness" type="floatPositive"/>
						<xs:attribute name="angle" type="xs:float"/>
						<xs:attribute name="filler">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="yes"/>
									<xs:enumeration value="no"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute name="filler_material" type="xs:string"/>
						<xs:attribute name="shape">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="straight"/>
									<xs:enumeration value="convex"/>
									<xs:enumeration value="concave"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute name="penetration">
							<xs:simpleType>
								<xs:restriction base="xs:float">
									<xs:minInclusive value="0"/>
									<xs:maxInclusive value="1"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
					</xs:complexType>
				</xs:element>
				<xs:element name="sheet_parameter" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:attribute name="index" type="partIndex" use="required"/>
						<xs:attribute name="gap" type="floatZeroPositive"/>
						<xs:attribute name="sheet_thickness" type="floatPositive"/>
						<xs:attribute name="sheet_angle" type="xs:float"/>
					</xs:complexType>
				</xs:element>
			</xs:all>
			<xs:attribute name="base" type="partIndex"/>
			<xs:attribute name="technology">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="resistance"/>
						<xs:enumeration value="arc"/>
						<xs:enumeration value="laser"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>

		<xs:unique name="unique_index_in_k_joint_sheet_parameter">
			<xs:selector xpath="sheet_parameter"/>
			<xs:field xpath="@index"/>
		</xs:unique>

	</xs:element>
	<xs:element name="cruciform_joint">
		<xs:complexType>
			<xs:all>
				<xs:element name="weld_position" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:attribute name="base" type="partIndex"/>
						<xs:attributeGroup ref="weld_position_common_attr"/>
						<xs:attribute name="section">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="HV"/>
									<xs:enumeration value="HY"/>
									<xs:enumeration value="Fillet"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute name="thickness" type="floatPositive"/>
						<xs:attribute name="angle" type="xs:float"/>
						<xs:attribute name="filler">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="yes"/>
									<xs:enumeration value="no"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute name="filler_material" type="xs:string"/>
						<xs:attribute name="shape">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="straight"/>
									<xs:enumeration value="convex"/>
									<xs:enumeration value="concave"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute name="penetration">
							<xs:simpleType>
								<xs:restriction base="xs:float">
									<xs:minInclusive value="0"/>
									<xs:maxInclusive value="1"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
					</xs:complexType>
				</xs:element>
				<xs:element name="sheet_parameter" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:attribute name="index" type="partIndex" use="required"/>
						<xs:attribute name="gap" type="floatZeroPositive"/>
						<xs:attribute name="sheet_thickness" type="floatPositive"/>
						<xs:attribute name="sheet_angle" type="xs:float"/>
					</xs:complexType>
				</xs:element>
			</xs:all>
			<xs:attribute name="base" type="partIndex"/>
			<xs:attribute name="technology">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="resistance"/>
						<xs:enumeration value="arc"/>
						<xs:enumeration value="laser"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>

		<xs:unique name="unique_index_in_cruciform_joint_sheet_parameter">
			<xs:selector xpath="sheet_parameter"/>
			<xs:field xpath="@index"/>
		</xs:unique>

	</xs:element>
	<xs:element name="flared_joint">
		<xs:complexType>
			<xs:all>
				<xs:element name="weld_position" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:attributeGroup ref="weld_position_common_attr"/>
						<xs:attribute name="width" type="floatPositive"/>
					</xs:complexType>
				</xs:element>
				<xs:element name="sheet_parameter" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:attribute name="index" type="partIndex" use="required"/>
						<xs:attribute name="gap" type="floatZeroPositive"/>
						<xs:attribute name="sheet_thickness" type="floatPositive"/>
					</xs:complexType>
				</xs:element>
			</xs:all>
			<xs:attribute name="base" type="partIndex"/>
			<xs:attribute name="technology">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="arc"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>

		<xs:unique name="unique_index_in_flared_joint_sheet_parameter">
			<xs:selector xpath="sheet_parameter"/>
			<xs:field xpath="@index"/>
		</xs:unique>

	</xs:element>
	<xs:element name="adhesive_line" substitutionGroup="connection_1d_type">
		<xs:complexType>
			<xs:attribute name="base" type="partIndex"/>
			<xs:attribute name="width" type="floatZeroPositive"/>
			<xs:attribute name="thickness" type="floatZeroPositive"/>
			<xs:attribute name="material" type="xs:string"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="hemming" substitutionGroup="connection_1d_type">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="region" minOccurs="0" maxOccurs="3"/>
			</xs:sequence>
			<xs:attribute name="folded_width" type="floatPositive"/>
			<xs:attribute name="folded_part" type="partIndex"/>

			<xs:assert test="count(hemming/region[@label='A']) le 1"/>
			<xs:assert test="count(hemming/region[@label='B']) le 1"/>
			<xs:assert test="count(hemming/region[@label='C']) le 1"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="region">
		<xs:complexType>
			<xs:choice minOccurs="0" maxOccurs="1">
				<xs:element ref="connection_1d"/>
				<xs:element ref="connection_2d"/>
			</xs:choice>
			<xs:attribute name="label" use="required">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="A"/>
						<xs:enumeration value="B"/>
						<xs:enumeration value="C"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="fill_percentage">
				<xs:simpleType>
					<xs:restriction base="xs:float">
						<xs:minInclusive value="0"/>
						<xs:maxInclusive value="100"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="top_index" type="partIndex"/>
			<xs:attribute name="bottom_index" type="partIndex"/>
			<xs:assert test="if( (@label eq 'A' or label eq 'C') and exists(connection_1d) and not(exists(connection_1d/adhesive_line))) then false() else true()"/>
			<xs:assert test="if( (@label eq 'A' or label eq 'C') and exists(connection_2d) and not(exists(connection_2d/adhesive_face))) then false() else true()"/>
			<xs:assert test="if( (@label eq 'B') and (exists(connection_1d) or exists(connection_2d)) ) then false() else true()"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="sequence_connection_0d" substitutionGroup="connection_1d_type">
		<xs:complexType>
			<xs:all>
				<xs:element ref="sequence_connection_0d_type" minOccurs="0" maxOccurs="1"/>
			</xs:all>
			<xs:attribute name="spacing" type="floatZeroPositive" use="required"/>
			<xs:attribute name="margin" type="floatZeroPositive" default="0.0"/>
			<xs:attribute name="priority" default="spacing">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="spacing"/>
						<xs:enumeration value="margin"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="sequence_connection_0d_type" abstract="true"/>
	<!-- ***************************************************************************************************************************************************************************** -->
	<xs:element name="connection_2d">
		<xs:complexType>
			<xs:all>
				<xs:element ref="adhesive_face" minOccurs="0" maxOccurs="1"/>
				<xs:element name="loc_list" minOccurs="1" maxOccurs="1">
					<xs:complexType>
						<xs:sequence>
							<xs:element name="loc" minOccurs="3" maxOccurs="unbounded">
								<xs:complexType>
									<xs:simpleContent>
										<xs:extension base="xs:string">
											<xs:attribute name="v" type="xs:integer" use="required"/>
										</xs:extension>
									</xs:simpleContent>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
				<xs:element ref="face_list" minOccurs="1" maxOccurs="1"/>
				<xs:element ref="appdata" minOccurs="0" maxOccurs="1"/>
				<xs:element ref="femdata" minOccurs="0" maxOccurs="1"/>
				<xs:element ref="custom_attributes_list" minOccurs="0" maxOccurs="1"/>
			</xs:all>
			<xs:attribute name="label" type="xs:string"/>
			<xs:attribute name="quality_control" type="xs:string"/>
<!--
			<xs:assert test="every $x in face_list/face satisfies loc_list/loc[@v=$x/@v1]"/>
			<xs:assert test="every $x in face_list/face satisfies loc_list/loc[@v=$x/@v2]"/>
			<xs:assert test="every $x in face_list/face satisfies loc_list/loc[@v=$x/@v3]"/>
			<xs:assert test="every $x in face_list/face/@v4 satisfies loc_list/loc[@v=$x]"/>
-->			
			<!--<xs:assert test="matches(./face_list/face/@v4, ./loc_list/loc/@v)"/>-->
		</xs:complexType>
		<xs:unique name="unique_v_in_loc_list">
			<xs:selector xpath="loc_list/loc"/>
			<xs:field xpath="@v"/>
		</xs:unique>
		<xs:key name="face_vertex_key">
			<xs:selector xpath="loc_list/loc"/>
			<xs:field xpath="@v"/>
		</xs:key>
		<xs:keyref name="face_v1_keyref" refer="face_vertex_key">
			<xs:selector xpath="face_list/face"/>
			<xs:field xpath="@v1"/>
		</xs:keyref>
		<xs:keyref name="face_v2_keyref" refer="face_vertex_key">
			<xs:selector xpath="face_list/face"/>
			<xs:field xpath="@v2"/>
		</xs:keyref>
		<xs:keyref name="face_v3_keyref" refer="face_vertex_key">
			<xs:selector xpath="face_list/face"/>
			<xs:field xpath="@v3"/>
		</xs:keyref>
		<xs:keyref name="face_v4_keyref" refer="face_vertex_key">
			<xs:selector xpath="face_list/face"/>
			<xs:field xpath="@v4"/>
		</xs:keyref>
	</xs:element>
	
	<xs:element name="adhesive_face">
		<xs:complexType>
			<xs:attribute name="base" type="partIndex"/>
			<xs:attribute name="thickness" type="floatZeroPositive"/>
			<xs:attribute name="material" type="xs:string"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="face_list">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="face" minOccurs="1" maxOccurs="unbounded"/>
			</xs:sequence>
		</xs:complexType>
	</xs:element>
	<xs:element name="face">
		<xs:complexType>
			<xs:attribute name="v1" type="xs:integer" use="required"/>
			<xs:attribute name="v2" type="xs:integer" use="required"/>
			<xs:attribute name="v3" type="xs:integer" use="required"/>
			<xs:attribute name="v4" type="xs:integer" use="optional"/>

			<xs:assert test="not(@v1=@v2) and not(@v1=@v3) and not(@v1=@v4) and not(@v2=@v3) and not(@v2=@v4) and not(@v3=@v4)"/>
		</xs:complexType>
	</xs:element>

	<!-- ***************************************************************************************************************************************************************************** -->
	<xs:attributeGroup name="weld_position_common_attr">
		<xs:attribute name="u" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:float">
					<xs:minInclusive value="0"/>
					<xs:maxInclusive value="1"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="x" type="xs:float" use="required"/>
		<xs:attribute name="y" type="xs:float" use="required"/>
		<xs:attribute name="z" type="xs:float" use="required"/>
		<xs:attribute name="reference" type="xs:boolean" default="false"/>
	</xs:attributeGroup>
	<xs:simpleType name="partIndex">
		<xs:restriction base="integerPositive"/>
	</xs:simpleType>
	<xs:simpleType name="integerPositive">
		<xs:restriction base="xs:integer">
			<xs:minExclusive value="0"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="floatPositive">
		<xs:restriction base="xs:float">
			<xs:minExclusive value="0.0"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="floatZeroPositive">
		<xs:restriction base="xs:float">
			<xs:minInclusive value="0.0"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="nonEmptyString">
		<xs:restriction base="xs:string">
			<xs:minLength value="1"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:element name="custom_attributes_list">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="custom_attributes" minOccurs="1" maxOccurs="unbounded"/>
			</xs:sequence>
		</xs:complexType>
		<xs:unique name="unique_owner_and_for_in_custom_attributes">
			<xs:selector xpath="custom_attributes"/>
			<xs:field xpath="@owner"/>
			<xs:field xpath="@for"/>
		</xs:unique>
	</xs:element>
	<xs:element name="custom_attributes">
		<xs:complexType>
			<xs:choice minOccurs="1" maxOccurs="unbounded">
				<xs:element ref="string"/>
				<xs:element ref="real"/>
				<xs:element ref="int"/>
				<xs:element ref="string_list"/>
				<xs:element ref="real_list"/>
				<xs:element ref="int_list"/>
			</xs:choice>
			<xs:attribute name="owner" type="nonEmptyString" use="required"/>
			<xs:attribute name="for" type="nonEmptyString"/>
		</xs:complexType>
		<xs:unique name="unique_key_in_string">
			<xs:selector xpath="string"/>
			<xs:field xpath="@key"/>
		</xs:unique>
		<xs:unique name="unique_key_in_real">
			<xs:selector xpath="real"/>
			<xs:field xpath="@key"/>
		</xs:unique>
		<xs:unique name="unique_key_in_int">
			<xs:selector xpath="int"/>
			<xs:field xpath="@key"/>
		</xs:unique>
		<xs:unique name="unique_key_in_string_list">
			<xs:selector xpath="string_list"/>
			<xs:field xpath="@key"/>
		</xs:unique>
		<xs:unique name="unique_key_in_real_list">
			<xs:selector xpath="real_list"/>
			<xs:field xpath="@key"/>
		</xs:unique>
		<xs:unique name="unique_key_in_int_list">
			<xs:selector xpath="int_list"/>
			<xs:field xpath="@key"/>
		</xs:unique>
	</xs:element>
	<xs:element name="string">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="xs:string">
					<xs:attribute name="key" type="nonEmptyString" use="required"/>
				</xs:extension>	
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="real">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="xs:float">
					<xs:attribute name="key" type="nonEmptyString" use="required"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="int">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="xs:int">
					<xs:attribute name="key" type="nonEmptyString" use="required"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="string_list">
		<xs:complexType>
			<xs:sequence>
				<xs:element name="value" minOccurs="1" maxOccurs="unbounded">
					<xs:complexType>
						<xs:simpleContent>
							<xs:extension base="xs:string">
								<xs:attribute name="index" type="integerPositive" use="required"/>
							</xs:extension>
						</xs:simpleContent>
					</xs:complexType>
				</xs:element>
			</xs:sequence>
			<xs:attribute name="key" type="nonEmptyString" use="required"/>
		</xs:complexType>
		<xs:unique name="unique_value_index_in_string_list">
			<xs:selector xpath="value"/>
			<xs:field xpath="@index"/>
		</xs:unique>
	</xs:element>
	<xs:element name="real_list">
		<xs:complexType>
			<xs:sequence>
				<xs:element name="value" minOccurs="1" maxOccurs="unbounded">
					<xs:complexType>
						<xs:simpleContent>
							<xs:extension base="xs:float">
								<xs:attribute name="index" type="integerPositive" use="required"/>
							</xs:extension>
						</xs:simpleContent>
					</xs:complexType>
				</xs:element>
			</xs:sequence>
			<xs:attribute name="key" type="nonEmptyString" use="required"/>
		</xs:complexType>
		<xs:unique name="unique_value_index_in_real_list">
			<xs:selector xpath="value"/>
			<xs:field xpath="@index"/>
		</xs:unique>
	</xs:element>
	<xs:element name="int_list">
		<xs:complexType>
			<xs:sequence>
				<xs:element name="value" minOccurs="1" maxOccurs="unbounded">
					<xs:complexType>
						<xs:simpleContent>
							<xs:extension base="xs:int">
								<xs:attribute name="index" type="integerPositive" use="required"/>
							</xs:extension>
						</xs:simpleContent>
					</xs:complexType>
				</xs:element>
			</xs:sequence>
			<xs:attribute name="key" type="nonEmptyString" use="required"/>
		</xs:complexType>
		<xs:unique name="unique_value_index_in_int_list">
			<xs:selector xpath="value"/>
			<xs:field xpath="@index"/>
		</xs:unique>
	</xs:element>
</xs:schema>
